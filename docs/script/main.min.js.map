{"version":3,"sources":["webpack://image-stylization-sines/./src/ts/helpers.ts","webpack://image-stylization-sines/./src/ts/input-image.ts","webpack://image-stylization-sines/./src/ts/interfaces/i-point.ts","webpack://image-stylization-sines/./src/ts/lines/lines-base.ts","webpack://image-stylization-sines/./src/ts/lines/lines-polygon.ts","webpack://image-stylization-sines/./src/ts/lines/lines-sines.ts","webpack://image-stylization-sines/./src/ts/lines/lines-spiral.ts","webpack://image-stylization-sines/./src/ts/lines/lines-straight-lines.ts","webpack://image-stylization-sines/./src/ts/main.ts","webpack://image-stylization-sines/./src/ts/parameters.ts","webpack://image-stylization-sines/./src/ts/plotter/plotter-base.ts","webpack://image-stylization-sines/./src/ts/plotter/plotter-canvas-2d.ts","webpack://image-stylization-sines/./src/ts/plotter/plotter-svg.ts","webpack://image-stylization-sines/webpack/bootstrap","webpack://image-stylization-sines/webpack/startup"],"names":["buildPlotterInfos","backgroundColor","Parameters","invertColors","lineColor","lineThickness","blur","chooseBestSamplingFunction","trueIntensity","inputImage","coords","Math","sqrt","sample","computeNormalRotationFunction","angle","PI","cosAngle","cos","sinAngle","sin","lengthAdjustment","normal","x","y","computeWaveFunction","waveSquareness","phase","amplitude","sharpness","sinPhase","sign","pow","abs","chooseLines","imageSizeInPlotter","linesSpacing","chosenType","linesType","ELinesType","STRAIGHT","LinesStraightLines","SPIRAL","LinesSpiral","POLYGON","LinesPolygon","LinesSines","downloadTextFile","content","filename","fileType","blob","Blob","type","window","navigator","msSaveBlob","URL","createObjectURL","linkElement","document","createElement","download","href","dataset","downloadurl","style","display","body","appendChild","click","removeChild","setTimeout","revokeObjectURL","image","this","hiddenCanvas","hiddenContext","getContext","sourceImage","_size","width","height","resize","wantedSize","wantedWidth","min","wantedHeight","console","log","drawImage","fullPixelsArray","getImageData","data","valueArray","Uint8ClampedArray","i","length","r","g","b","normalizedCoords","pixelCoords","floorPixelCoords","floor","fractPixelCoords","topLeft","getPixel","topRight","bottomLeft","bottomRight","top","interpolate","bottom","a","InputImage","distance","dX","dY","rotate","p","LinesBase","imageSize","_center","_suggestedImageSize","_linesSpacing","_nbSides","linesSides","diagonal","_maxSegments","ceil","walkOnLine","_lineId","step","callback","insideAngle","dSideLength","tan","startSideLength","orientationAngle","orientationInRadians","cosOrientation","sinOrientation","startPoint","iSide","sideLength","tangentAngle","endPoint","normalAngle","segmentLength","iSubstep","progression","rawPointX","rawPointY","_frequency","linesFrequency","_amplitude","linesAmplitude","max","_normal","_lines","push","computeLine","maxAbsLine","computeMaximumLinesNeeded","iAbsLine","iLine","line","lineId","computePoint","completion","wave","start","end","maxNbSteps","iStep","lineLength","tangent","center","_radiusGap","nbSemiCircles","_maxAngle","orientation","semiCircleId","radius","centerOffset","ELinesOrientation","linesOrientation","DIAGONAL","orientationInDegrees","VERTICAL","HORIZONTAL","xOutOfBounds","yOutOfBounds","computeBestImageSize","maxX","maxY","startAdjustment","endAdjustment","nbLines","plot","plotter","performance","now","displayInfos","Helpers","initialize","imageFitting","fitImage","sourceImageAspectRatio","linesCount","zoomFactor","maxFrequency","maxAmplitude","lines","sizeInPlotter","suggestedImageSize","samplingFunction","normalRotation","waveFunction","point","hasStartedALine","endLine","startLine","localDarkness","localHeight","rotatedNormal","absolutePoint","relativeToAbsolute","addPointToLine","finalize","canvasPlotter","PlotterCanvas2D","plotOnCanvas","updateBlur","onImageLoad","Page","Canvas","showLoader","addRedrawObserver","addBlurChangeObserver","addDownloadObserver","svgPlotter","PlotterSVG","svgString","export","addFileUploadObserver","defaultImage","Image","addEventListener","src","controlId","redrawObservers","triggerRedraw","observer","udpateLinesControlsVisibility","Tabs","getValues","Controls","setVisibility","SINES","addObserver","Range","addLazyObserver","Checkbox","Observers","canvasResize","FileControl","addUploadObserver","filesList","FileReader","onload","result","readAsDataURL","getValue","isChecked","ANGLE_THRESHOLD","_hasStartedALine","startLineInternal","lastDrawnPoint","potentialNextPoint","newPoint","addFirstPointToLineInternal","PlotterBase","computeAngle","addPointToLineInternal","endLineInternal","imageAspectRatio","plotterSize","size","displayAspectRatio","offSetX","offSetY","relativeCoords","p1","p2","p3","angle1","atan2","angle2","diffAngle","canvas","getCanvas","context","alpha","cssPixel","devicePixelRatio","infos","resizeCanvas","fillStyle","strokeStyle","lineWidth","lineJoin","lineCap","roundLinecap","fillRect","value","filter","beginPath","rawX","rawY","moveTo","lineTo","stroke","closePath","actualWidth","clientWidth","actualHeight","clientHeight","hasBlur","stringParts","linecap","Date","join","toFixed","__webpack_module_cache__","__webpack_require__","moduleId","exports","module","__webpack_modules__","call"],"mappings":"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","file":"main.min.js","sourcesContent":["import { InputImage } from \"./input-image\";\r\nimport { IPoint } from \"./interfaces/i-point\";\r\nimport { ISize } from \"./interfaces/i-size\";\r\nimport { Parameters, ELinesType } from \"./parameters\";\r\nimport { LinesBase } from \"./lines/lines-base\";\r\nimport { LinesStraightLines } from \"./lines/lines-straight-lines\";\r\nimport { LinesSines } from \"./lines/lines-sines\";\r\nimport { LinesSpiral } from \"./lines/lines-spiral\";\r\nimport { IPlotterInfo } from \"./plotter/plotter-base\";\r\nimport { LinesPolygon } from \"./lines/lines-polygon\";\r\n\r\nfunction buildPlotterInfos(): IPlotterInfo {\r\n    return {\r\n        backgroundColor: Parameters.invertColors ? \"black\" : \"white\",\r\n        lineColor: Parameters.invertColors ? \"white\" : \"black\",\r\n        lineThickness: Parameters.lineThickness,\r\n        blur: Parameters.blur,\r\n    };\r\n}\r\n\r\ntype SamplingFunction = (inputImage: InputImage, coords: IPoint) => number;\r\nfunction chooseBestSamplingFunction(): SamplingFunction {\r\n    if (Parameters.trueIntensity) {\r\n        if (Parameters.invertColors) {\r\n            return (inputImage: InputImage, coords: IPoint) => Math.sqrt(inputImage.sample(coords));\r\n        } else {\r\n            return (inputImage: InputImage, coords: IPoint) => Math.sqrt(1.001 - inputImage.sample(coords));\r\n        }\r\n    } else {\r\n        if (Parameters.invertColors) {\r\n            return (inputImage: InputImage, coords: IPoint) => inputImage.sample(coords);\r\n        } else {\r\n            return (inputImage: InputImage, coords: IPoint) => 1 - inputImage.sample(coords);\r\n        }\r\n    }\r\n}\r\n\r\ntype NormalRotationFunction = (normal: IPoint) => IPoint;\r\nfunction computeNormalRotationFunction(): NormalRotationFunction {\r\n    const angle = Parameters.angle * 2 * Math.PI;\r\n    const cosAngle = Math.cos(angle);\r\n    const sinAngle = Math.sin(angle);\r\n    const lengthAdjustment = 1 / cosAngle; // to maintain the waves height no matter the angle\r\n    return (normal: IPoint): IPoint => {\r\n        return {\r\n            x: (cosAngle * normal.x - sinAngle * normal.y) * lengthAdjustment,\r\n            y: (sinAngle * normal.x + cosAngle * normal.y) * lengthAdjustment,\r\n        };\r\n    };\r\n}\r\n\r\ntype WaveFunction = (phase: number, amplitude: number) => number;\r\nfunction computeWaveFunction(): WaveFunction {\r\n    if (Parameters.waveSquareness < 0.005) {\r\n        return (phase: number, amplitude: number) => amplitude * Math.sin(phase);\r\n    }\r\n\r\n    const sharpness = 1 - 0.99 * Parameters.waveSquareness;\r\n    return (phase: number, amplitude: number) => {\r\n        const sinPhase = Math.sin(phase);\r\n        return amplitude * Math.sign(sinPhase) * Math.pow(Math.abs(sinPhase), sharpness);\r\n    };\r\n}\r\n\r\nfunction chooseLines(imageSizeInPlotter: ISize, linesSpacing: number): LinesBase {\r\n    const chosenType = Parameters.linesType;\r\n    if (chosenType === ELinesType.STRAIGHT) {\r\n        return new LinesStraightLines(imageSizeInPlotter, linesSpacing);\r\n    } else if (chosenType === ELinesType.SPIRAL) {\r\n        return new LinesSpiral(imageSizeInPlotter, linesSpacing);\r\n    } else if (chosenType === ELinesType.POLYGON) {\r\n        return new LinesPolygon(imageSizeInPlotter, linesSpacing);\r\n    } else {\r\n        return new LinesSines(imageSizeInPlotter, linesSpacing);\r\n    }\r\n}\r\n\r\nfunction downloadTextFile(content: string, filename: string): void {\r\n    const fileType = \"text/plain\";\r\n\r\n    const blob = new Blob([content], { type: fileType });\r\n\r\n    if (typeof window.navigator !== \"undefined\" && typeof window.navigator.msSaveBlob !== \"undefined\") { // for IE\r\n        window.navigator.msSaveBlob(blob, filename);\r\n    } else {\r\n        const objectUrl = URL.createObjectURL(blob);\r\n\r\n        const linkElement = document.createElement('a');\r\n        linkElement.download = filename;\r\n        linkElement.href = objectUrl;\r\n        linkElement.dataset.downloadurl = `${fileType}:${linkElement.download}:${linkElement.href}`;\r\n        linkElement.style.display = \"none\";\r\n        document.body.appendChild(linkElement);\r\n        linkElement.click();\r\n        document.body.removeChild(linkElement);\r\n\r\n        // don't forget to free the objectURL after a few seconds\r\n        setTimeout(() => {\r\n            URL.revokeObjectURL(objectUrl);\r\n        }, 5000);\r\n    }\r\n}\r\n\r\nexport {\r\n    buildPlotterInfos,\r\n    chooseBestSamplingFunction,\r\n    chooseLines,\r\n    computeNormalRotationFunction,\r\n    computeWaveFunction,\r\n    downloadTextFile,\r\n};\r\n","import { ISize } from \"./interfaces/i-size\";\r\nimport { IPoint } from \"./interfaces/i-point\";\r\n\r\nclass InputImage {\r\n    private _size: ISize;\r\n\r\n    private readonly hiddenCanvas: HTMLCanvasElement;\r\n    private readonly hiddenContext: CanvasRenderingContext2D;\r\n    private readonly sourceImage: HTMLImageElement;\r\n    private valueArray: Uint8ClampedArray;\r\n\r\n    public constructor(image: HTMLImageElement) {\r\n        this.hiddenCanvas = document.createElement(\"canvas\");\r\n        this.hiddenContext = this.hiddenCanvas.getContext(\"2d\");\r\n        this.sourceImage = image;\r\n        this._size = {\r\n            width: 0,\r\n            height: 0,\r\n        };\r\n\r\n        this.resize({ width: image.width, height: image.height });\r\n    }\r\n\r\n    public get size(): ISize {\r\n        return this._size;\r\n    }\r\n\r\n    public get width(): number {\r\n        return this._size.width;\r\n    }\r\n\r\n    public get height(): number {\r\n        return this._size.height;\r\n    }\r\n\r\n    public get sourceImageAspectRatio(): number {\r\n        return this.sourceImage.width / this.sourceImage.height;\r\n    }\r\n\r\n    public resize(wantedSize: ISize): void {\r\n        // the canvas handles image downsizing, however upsizing is handled manually in the sample method.\r\n        const wantedWidth = Math.min(this.sourceImage.width, wantedSize.width);\r\n        const wantedHeight = Math.min(this.sourceImage.height, wantedSize.height);\r\n\r\n        if (this.width !== wantedWidth || this.height !== wantedHeight) {\r\n            console.log(`Resize image from ${this.width}x${this.height} to ${wantedWidth}x${wantedHeight}.`);\r\n\r\n            this._size.width = wantedWidth;\r\n            this._size.height = wantedHeight;\r\n\r\n            this.hiddenCanvas.width = this.width;\r\n            this.hiddenCanvas.height = this.height;\r\n            this.hiddenContext.drawImage(this.sourceImage, 0, 0, this.width, this.height);\r\n\r\n            // retrieve all pixels at once because it is way faster that 1 by 1\r\n            const fullPixelsArray = this.hiddenContext.getImageData(0, 0, this.width, this.height).data;\r\n            this.valueArray = new Uint8ClampedArray(this.width * this.height);\r\n\r\n            for (let i = 0; i < this.valueArray.length; i++) {\r\n                const r = fullPixelsArray[4 * i];\r\n                const g = fullPixelsArray[4 * i + 1];\r\n                const b = fullPixelsArray[4 * i + 2];\r\n                this.valueArray[i] = (r + g + b) / 3;\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Returns a value in [0, 1]. Performs linear interpolation. */\r\n    public sample(normalizedCoords: IPoint): number {\r\n        const pixelCoords: IPoint = {\r\n            x: normalizedCoords.x * (this._size.width - 1),\r\n            y: normalizedCoords.y * (this._size.height - 1),\r\n        }\r\n\r\n        const floorPixelCoords: IPoint = {\r\n            x: Math.floor(pixelCoords.x),\r\n            y: Math.floor(pixelCoords.y),\r\n        };\r\n        const fractPixelCoords: IPoint = {\r\n            x: pixelCoords.x - floorPixelCoords.x,\r\n            y: pixelCoords.y - floorPixelCoords.y,\r\n        };\r\n\r\n        const topLeft = this.getPixel(floorPixelCoords.x, floorPixelCoords.y);\r\n        const topRight = this.getPixel(floorPixelCoords.x + 1, floorPixelCoords.y);\r\n        const bottomLeft = this.getPixel(floorPixelCoords.x, floorPixelCoords.y + 1);\r\n        const bottomRight = this.getPixel(floorPixelCoords.x + 1, floorPixelCoords.y + 1);\r\n\r\n        const top = this.interpolate(topLeft, topRight, fractPixelCoords.x);\r\n        const bottom = this.interpolate(bottomLeft, bottomRight, fractPixelCoords.x);\r\n\r\n        const interpolated = this.interpolate(top, bottom, fractPixelCoords.y);\r\n\r\n        return interpolated / 255;\r\n    }\r\n\r\n    private interpolate(a: number, b: number, x: number): number {\r\n        return a * (1 - x) + b * x;\r\n    }\r\n\r\n    /** Returns a value in [0, 255]. No interpolation.\r\n     * @param x in pixels, must be an integer\r\n     * @param y in pixels, must be an integer\r\n     */\r\n    private getPixel(x: number, y: number): number {\r\n        if (x < 0 || y < 0 || x >= this.width || y >= this.height) {\r\n            return 0;\r\n        }\r\n\r\n        return this.valueArray[y * this.width + x];\r\n    }\r\n}\r\n\r\nexport { InputImage }\r\n","interface IPoint {\r\n    x: number;\r\n    y: number;\r\n}\r\n\r\nfunction distance(a: IPoint, b: IPoint): number {\r\n    const dX = a.x - b.x;\r\n    const dY = a.y - b.y;\r\n    return Math.sqrt(dX * dX + dY * dY);\r\n}\r\n\r\nfunction rotate(p: IPoint, angle: number): IPoint {\r\n    const cosAngle = Math.cos(angle);\r\n    const sinAngle = Math.sin(angle);\r\n\r\n    return {\r\n        x: p.x * cosAngle - p.y * sinAngle,\r\n        y: p.x * sinAngle + p.y * cosAngle,\r\n    };\r\n}\r\n\r\nexport { IPoint, distance, rotate }\r\n","import { IPoint } from \"../interfaces/i-point\";\r\nimport { ISize } from \"../interfaces/i-size\";\r\n\r\ntype LineWalker = (point: IPoint, normal: IPoint) => unknown;\r\n\r\nabstract class LinesBase {\r\n    /** Returns the suggested image size for optimum quality */\r\n    public abstract get suggestedImageSize(): ISize;\r\n    public abstract get nbLines(): number;\r\n\r\n    /**\r\n     * @param lineId integer\r\n     * @param step in canvas pixels\r\n     */\r\n    public abstract walkOnLine(lineId: number, step: number, callback: LineWalker): void;\r\n}\r\n\r\nexport { LineWalker, LinesBase }\r\n","import { distance, IPoint } from \"../interfaces/i-point\";\r\nimport { ISize } from \"../interfaces/i-size\";\r\nimport { Parameters } from \"../parameters\";\r\nimport { LineWalker, LinesBase } from \"./lines-base\";\r\n\r\nclass LinesPolygon extends LinesBase {\r\n    private readonly _center: IPoint;\r\n    private readonly _suggestedImageSize: ISize;\r\n    private readonly _linesSpacing: number;\r\n    private readonly _maxSegments: number;\r\n    private readonly _nbSides: number;\r\n\r\n    public constructor(imageSize: ISize, linesSpacing: number) {\r\n        super();\r\n\r\n        this._center = {\r\n            x: 0.5 * imageSize.width,\r\n            y: 0.5 * imageSize.height,\r\n        };\r\n\r\n        this._suggestedImageSize = {\r\n            width: imageSize.width,\r\n            height: imageSize.height,\r\n        };\r\n\r\n        this._linesSpacing = linesSpacing;\r\n        this._nbSides = Parameters.linesSides;\r\n\r\n        const diagonal = Math.sqrt(imageSize.width * imageSize.width + imageSize.height * imageSize.height);\r\n        this._maxSegments = Math.ceil(this._nbSides * diagonal / linesSpacing);\r\n    }\r\n\r\n    public get suggestedImageSize(): ISize {\r\n        return this._suggestedImageSize;\r\n    }\r\n\r\n    public get nbLines(): number {\r\n        return 1;\r\n    }\r\n\r\n    public walkOnLine(_lineId: number, step: number, callback: LineWalker): void {\r\n        const insideAngle = Math.PI * (this._nbSides - 2) / this._nbSides; // inside angle of a regular polygon\r\n        const dSideLength = 2 * this._linesSpacing / Math.tan(insideAngle / 2) / this._nbSides;\r\n        const startSideLength = 0.5 * dSideLength;\r\n\r\n        const orientationAngle = Parameters.orientationInRadians;\r\n        const cosOrientation = Math.cos(orientationAngle);\r\n        const sinOrientation = Math.sin(orientationAngle);\r\n\r\n        let startPoint: IPoint = {\r\n            x: this._center.x,\r\n            y: this._center.y,\r\n        };\r\n        for (let iSide = 0; iSide < this._maxSegments; iSide++) {\r\n            const sideLength = startSideLength + iSide * dSideLength;\r\n            const tangentAngle = Math.PI + (iSide % this._nbSides) * 2 * Math.PI / this._nbSides;\r\n\r\n            const endPoint: IPoint = {\r\n                x: startPoint.x + sideLength * Math.cos(tangentAngle),\r\n                y: startPoint.y + sideLength * Math.sin(tangentAngle),\r\n            };\r\n\r\n            const normalAngle = tangentAngle + orientationAngle + Math.PI / 2;\r\n            const normal: IPoint = { x: Math.cos(normalAngle), y: Math.sin(normalAngle) };\r\n\r\n            const segmentLength = distance(startPoint, endPoint);\r\n            for (let iSubstep = 0; iSubstep * step < segmentLength; iSubstep++) {\r\n                const currentLength = iSubstep * step;\r\n                const progression = currentLength / segmentLength;\r\n\r\n                const rawPointX = startPoint.x * (1 - progression) + endPoint.x * progression - this._center.x;\r\n                const rawPointY = startPoint.y * (1 - progression) + endPoint.y * progression - this._center.y;\r\n\r\n                const point: IPoint = {\r\n                    x: cosOrientation * rawPointX - sinOrientation * rawPointY + this._center.x,\r\n                    y: sinOrientation * rawPointX + cosOrientation * rawPointY + this._center.y,\r\n                };\r\n                callback(point, normal);\r\n            }\r\n\r\n            startPoint = endPoint;\r\n        }\r\n    }\r\n}\r\n\r\nexport { LinesPolygon };\r\n","import { ISize } from \"../interfaces/i-size\";\r\nimport { IPoint } from \"../interfaces/i-point\";\r\nimport { LineWalker, LinesBase } from \"./lines-base\";\r\n\r\nimport { Parameters } from \"../parameters\";\r\n\r\ninterface ILine {\r\n    start: IPoint;\r\n    end: IPoint;\r\n    length: number;\r\n}\r\n\r\nclass LinesSines extends LinesBase {\r\n    private readonly _suggestedImageSize: ISize;\r\n\r\n    private readonly _normal: IPoint;\r\n    private readonly _lines: ILine[];\r\n    private readonly _frequency: number;\r\n    private readonly _amplitude: number;\r\n\r\n    public constructor(imageSize: ISize, linesSpacing: number) {\r\n        super();\r\n\r\n        this._frequency = Parameters.linesFrequency;\r\n        this._amplitude = Parameters.linesAmplitude * 0.2 * Math.max(imageSize.width, imageSize.height);\r\n\r\n        this._normal = {\r\n            x: -Math.sin(Parameters.orientationInRadians),\r\n            y: Math.cos(Parameters.orientationInRadians),\r\n        };\r\n\r\n        this._lines = [];\r\n        this._lines.push(LinesSines.computeLine(0, linesSpacing, this._normal, imageSize));\r\n\r\n        const maximumLinesNeeded = this.computeMaximumLinesNeeded(imageSize, linesSpacing);\r\n        const maxAbsLine = maximumLinesNeeded / 2 + 1;\r\n        for (let iAbsLine = 1; iAbsLine < maxAbsLine; iAbsLine++) {\r\n            for (let iSide = -1; iSide <= 2; iSide += 2) {\r\n                const iLine = iAbsLine * iSide;\r\n                const line = LinesSines.computeLine(iLine, linesSpacing, this._normal, imageSize);\r\n                this._lines.push(line);\r\n            }\r\n        }\r\n        this._suggestedImageSize = { width: imageSize.width, height: imageSize.height };\r\n    }\r\n\r\n    public get suggestedImageSize(): ISize {\r\n        return this._suggestedImageSize;\r\n    }\r\n\r\n    public get nbLines(): number {\r\n        return this._lines.length;\r\n    }\r\n\r\n    public walkOnLine(lineId: number, step: number, callback: LineWalker): void {\r\n        const line = this._lines[lineId];\r\n\r\n        const computePoint = (completion: number): IPoint => {\r\n            const wave = this._amplitude * Math.sin(2 * Math.PI * completion * this._frequency);\r\n            return {\r\n                x: line.start.x * (1 - completion) + line.end.x * completion + wave * this._normal.x,\r\n                y: line.start.y * (1 - completion) + line.end.y * completion + wave * this._normal.y,\r\n            };\r\n        }\r\n\r\n        const maxNbSteps = line.length / step;\r\n        for (let iStep = 0; iStep < maxNbSteps; iStep++) {\r\n            const completion = (iStep * step) / line.length;\r\n\r\n            const point = computePoint(completion);\r\n            callback(point, this._normal);\r\n        }\r\n\r\n        const lastPoint = computePoint(1);\r\n        callback(lastPoint, this._normal);\r\n    }\r\n\r\n    private static computeLine(iLine: number, linesSpacing: number, normal: IPoint, imageSize: ISize): ILine {\r\n        const lineLength = Math.sqrt(imageSize.width * imageSize.width + imageSize.height * imageSize.height);\r\n        const tangent: IPoint = {\r\n            x: normal.y,\r\n            y: -normal.x,\r\n        };\r\n\r\n        const center: IPoint = {\r\n            x: 0.5 * imageSize.width + iLine * linesSpacing * normal.x,\r\n            y: 0.5 * imageSize.height + iLine * linesSpacing * normal.y,\r\n        };\r\n\r\n        const start: IPoint = {\r\n            x: center.x - 0.5 * lineLength * tangent.x,\r\n            y: center.y - 0.5 * lineLength * tangent.y,\r\n        };\r\n\r\n        const end: IPoint = {\r\n            x: center.x + 0.5 * lineLength * tangent.x,\r\n            y: center.y + 0.5 * lineLength * tangent.y,\r\n        };\r\n\r\n        return {\r\n            start,\r\n            end,\r\n            length: lineLength, // this is not mathematically accurate\r\n        };\r\n    }\r\n\r\n    private computeMaximumLinesNeeded(imageSize: ISize, linesSpacing: number): number {\r\n        const width = imageSize.width + 2 * this._amplitude;\r\n        const height = imageSize.height + 2 * this._amplitude;\r\n\r\n        const diagonal = Math.sqrt(width * width + height * height);\r\n        return Math.ceil(diagonal / linesSpacing);\r\n    }\r\n}\r\n\r\nexport { LinesSines }\r\n","import { IPoint } from \"../interfaces/i-point\";\r\nimport { ISize } from \"../interfaces/i-size\";\r\nimport { Parameters } from \"../parameters\";\r\nimport { LineWalker, LinesBase } from \"./lines-base\";\r\n\r\nclass LinesSpiral extends LinesBase {\r\n    private readonly _center: IPoint;\r\n    private readonly _suggestedImageSize: ISize;\r\n    private readonly _radiusGap: number;\r\n    private readonly _maxAngle: number;\r\n\r\n    public constructor(imageSize: ISize, linesSpacing: number) {\r\n        super();\r\n\r\n        this._center = {\r\n            x: 0.5 * imageSize.width,\r\n            y: 0.5 * imageSize.height,\r\n        };\r\n\r\n        this._suggestedImageSize = {\r\n            width: imageSize.width,\r\n            height: imageSize.height,\r\n        };\r\n\r\n        this._radiusGap = 0.5 * linesSpacing;\r\n\r\n        const diagonal = Math.sqrt(imageSize.width * imageSize.width + imageSize.height * imageSize.height);\r\n        const nbSemiCircles = Math.ceil(diagonal / linesSpacing);\r\n        this._maxAngle = nbSemiCircles * Math.PI;\r\n    }\r\n\r\n    public get suggestedImageSize(): ISize {\r\n        return this._suggestedImageSize;\r\n    }\r\n\r\n    public get nbLines(): number {\r\n        return 1;\r\n    }\r\n\r\n    public walkOnLine(_lineId: number, step: number, callback: LineWalker): void {\r\n        const orientation = Parameters.orientationInRadians;\r\n        const cosOrientation = Math.cos(orientation);\r\n        const sinOrientation = Math.sin(orientation);\r\n\r\n        let angle = 0;\r\n        while (angle < this._maxAngle) {\r\n            const cosAngle = Math.cos(angle);\r\n            const sinAngle = Math.sin(angle);\r\n\r\n            const semiCircleId = Math.ceil((angle - orientation) / Math.PI);\r\n            const radius = (semiCircleId + 0.125) * this._radiusGap;\r\n            const centerOffset = this._radiusGap * (0.5 - (semiCircleId % 2));\r\n\r\n            const point: IPoint = {\r\n                x: this._center.x + centerOffset * cosOrientation + radius * cosAngle,\r\n                y: this._center.y + centerOffset * sinOrientation + radius * sinAngle,\r\n            };\r\n            const normal: IPoint = {\r\n                x: -cosAngle,\r\n                y: -sinAngle,\r\n            };\r\n\r\n            callback(point, normal);\r\n\r\n            angle += step / radius;\r\n        }\r\n    }\r\n}\r\n\r\nexport { LinesSpiral }\r\n","import { ISize } from \"../interfaces/i-size\";\r\nimport { IPoint, distance } from \"../interfaces/i-point\";\r\nimport { LineWalker, LinesBase } from \"./lines-base\";\r\n\r\nimport { Parameters } from \"../parameters\";\r\n\r\ninterface ILine {\r\n    start: IPoint;\r\n    end: IPoint;\r\n    length: number;\r\n}\r\n\r\nenum ELinesOrientation {\r\n    HORIZONTAL,\r\n    VERTICAL,\r\n    DIAGONAL,\r\n}\r\n\r\nclass LinesStraightLines extends LinesBase {\r\n    private readonly _suggestedImageSize: ISize;\r\n\r\n    private readonly _normal: IPoint;\r\n    private readonly _lines: ILine[];\r\n\r\n    public constructor(imageSize: ISize, linesSpacing: number) {\r\n        super();\r\n\r\n        this._normal = {\r\n            x: -Math.sin(Parameters.orientationInRadians),\r\n            y: Math.cos(Parameters.orientationInRadians),\r\n        };\r\n\r\n        let linesOrientation = ELinesOrientation.DIAGONAL;\r\n        if (Parameters.orientationInDegrees % 180 === 90) {\r\n            linesOrientation = ELinesOrientation.VERTICAL;\r\n        } else if (Parameters.orientationInDegrees % 180 === 0) {\r\n            linesOrientation = ELinesOrientation.HORIZONTAL;\r\n        }\r\n\r\n        this._lines = [];\r\n        this._lines.push(LinesStraightLines.computeLine(0, linesSpacing, linesOrientation, this._normal, imageSize));\r\n\r\n        const maximumLinesNeeded = LinesStraightLines.computeMaximumLinesNeeded(imageSize, linesSpacing);\r\n        const maxAbsLine = maximumLinesNeeded / 2 + 1;\r\n        for (let iAbsLine = 1; iAbsLine < maxAbsLine; iAbsLine++) {\r\n            for (let iSide = -1; iSide <= 2; iSide += 2) {\r\n                const iLine = iAbsLine * iSide;\r\n                const line = LinesStraightLines.computeLine(iLine, linesSpacing, linesOrientation, this._normal, imageSize);\r\n\r\n                const ROUNDING_ERROR = 0.1;\r\n\r\n                const xOutOfBounds = line.start.x < -ROUNDING_ERROR || line.start.x > imageSize.width - 1 + ROUNDING_ERROR;\r\n                const yOutOfBounds = line.start.y < -ROUNDING_ERROR || line.start.y > imageSize.height - 1 + ROUNDING_ERROR;\r\n\r\n                if (xOutOfBounds || yOutOfBounds) {\r\n                    break;\r\n                }\r\n\r\n                this._lines.push(line);\r\n            }\r\n        }\r\n        this._suggestedImageSize = LinesStraightLines.computeBestImageSize(imageSize, this._lines.length, linesOrientation);\r\n    }\r\n\r\n    public get suggestedImageSize(): ISize {\r\n        return this._suggestedImageSize;\r\n    }\r\n\r\n    public get nbLines(): number {\r\n        return this._lines.length;\r\n    }\r\n\r\n    public walkOnLine(lineId: number, step: number, callback: LineWalker): void {\r\n        const line = this._lines[lineId];\r\n\r\n        function computePoint(completion: number): IPoint {\r\n            return {\r\n                x: line.start.x * (1 - completion) + line.end.x * completion,\r\n                y: line.start.y * (1 - completion) + line.end.y * completion,\r\n            };\r\n        }\r\n\r\n        const maxNbSteps = line.length / step;\r\n        for (let iStep = 0; iStep < maxNbSteps; iStep++) {\r\n            const completion = (iStep * step) / line.length;\r\n\r\n            const point = computePoint(completion);\r\n            callback(point, this._normal);\r\n        }\r\n\r\n        const lastPoint = computePoint(1);\r\n        callback(lastPoint, this._normal);\r\n    }\r\n\r\n    private static computeLine(iLine: number, linesSpacing: number, linesOrientation: ELinesOrientation, normal: IPoint, imageSize: ISize): ILine {\r\n        const tangent: IPoint = {\r\n            x: normal.y,\r\n            y: -normal.x,\r\n        };\r\n\r\n        const start: IPoint = {\r\n            x: 0.5 * imageSize.width + iLine * linesSpacing * normal.x,\r\n            y: 0.5 * imageSize.height + iLine * linesSpacing * normal.y,\r\n        };\r\n        const end: IPoint = { x: start.x, y: start.y };\r\n\r\n        const maxX = imageSize.width - 1;\r\n        const maxY = imageSize.height - 1;\r\n\r\n        if (linesOrientation === ELinesOrientation.HORIZONTAL) {\r\n            start.x = 0;\r\n            end.x = maxX;\r\n        } else if (linesOrientation === ELinesOrientation.VERTICAL) {\r\n            start.y = 0;\r\n            end.y = maxY;\r\n        } else {\r\n            const startAdjustment = Math.min(start.x / tangent.x, start.y / tangent.y);\r\n            start.x -= startAdjustment * tangent.x;\r\n            start.y -= startAdjustment * tangent.y;\r\n\r\n            const endAdjustment = Math.min((maxX - end.x) / tangent.x, (maxY - end.y) / tangent.y);\r\n            end.x += endAdjustment * tangent.x;\r\n            end.y += endAdjustment * tangent.y;\r\n        }\r\n\r\n        return {\r\n            start,\r\n            end,\r\n            length: distance(start, end),\r\n        };\r\n    }\r\n\r\n    private static computeBestImageSize(imageSize: ISize, nbLines: number, orientation: ELinesOrientation): ISize {\r\n        if (orientation === ELinesOrientation.HORIZONTAL) {\r\n            return {\r\n                width: imageSize.width,\r\n                height: nbLines,\r\n            };\r\n        } else if (orientation === ELinesOrientation.VERTICAL) {\r\n            return {\r\n                width: nbLines,\r\n                height: imageSize.height,\r\n            };\r\n        }\r\n\r\n        return {\r\n            width: imageSize.width,\r\n            height: imageSize.height,\r\n        };\r\n    }\r\n\r\n    private static computeMaximumLinesNeeded(imageSize: ISize, linesSpacing: number): number {\r\n        const diagonal = Math.sqrt(imageSize.width * imageSize.width + imageSize.height * imageSize.height)\r\n        return Math.ceil(diagonal / linesSpacing);\r\n    }\r\n}\r\n\r\nexport { LinesStraightLines }\r\n","import { Parameters } from \"./parameters\";\r\nimport { InputImage } from \"./input-image\";\r\n\r\nimport { IPoint } from \"./interfaces/i-point\";\r\n\r\nimport { PlotterBase } from \"./plotter/plotter-base\";\r\nimport { PlotterCanvas2D } from \"./plotter/plotter-canvas-2d\";\r\nimport { PlotterSVG } from \"./plotter/plotter-svg\";\r\n\r\nimport * as Helpers from \"./helpers\";\r\n\r\nimport \"./page-interface-generated\";\r\n\r\nfunction plot(image: InputImage, plotter: PlotterBase): void {\r\n    const start = performance.now();\r\n\r\n    if (image == null) {\r\n        console.log(\"Image not loaded!\");\r\n        return;\r\n    }\r\n\r\n    const displayInfos = Helpers.buildPlotterInfos();\r\n    plotter.initialize(displayInfos);\r\n\r\n    const imageFitting = plotter.fitImage(image.sourceImageAspectRatio);\r\n\r\n    const baseLineSpacing = 1 / Parameters.linesCount;\r\n    const linesSpacing = baseLineSpacing * imageFitting.zoomFactor;\r\n\r\n    const baseMaxFrequency = 500 * Parameters.maxFrequency;\r\n    const maxFrequency = baseMaxFrequency / imageFitting.zoomFactor;\r\n\r\n    const maxAmplitude = 0.5 * (linesSpacing - displayInfos.lineThickness) * Parameters.maxAmplitude;\r\n\r\n    const lines = Helpers.chooseLines(imageFitting.sizeInPlotter, linesSpacing);\r\n\r\n    image.resize(lines.suggestedImageSize);\r\n\r\n    const samplingFunction = Helpers.chooseBestSamplingFunction();\r\n    const normalRotation = Helpers.computeNormalRotationFunction();\r\n    const waveFunction = Helpers.computeWaveFunction();\r\n\r\n    const samplesPerPixel = Math.max(1, 2 * maxFrequency);\r\n    const step = 1 / samplesPerPixel;\r\n    for (let iLine = 0; iLine < lines.nbLines; iLine++) {\r\n        let phase = 0;\r\n        lines.walkOnLine(iLine, step, (point: IPoint, normal: IPoint) => {\r\n            const normalizedCoords: IPoint = {\r\n                x: point.x / (imageFitting.sizeInPlotter.width - 1),\r\n                y: point.y / (imageFitting.sizeInPlotter.height - 1),\r\n            };\r\n\r\n            const outOfImage = normalizedCoords.x < 0 || normalizedCoords.x > 1 || normalizedCoords.y < 0 || normalizedCoords.y > 1;\r\n            if (outOfImage) {\r\n                if (plotter.hasStartedALine) {\r\n                    plotter.endLine();\r\n                }\r\n                return;\r\n            } else if (!plotter.hasStartedALine) {\r\n                plotter.startLine();\r\n            }\r\n\r\n            const localDarkness = samplingFunction(image, normalizedCoords);\r\n\r\n            const localAmplitude = localDarkness * maxAmplitude;\r\n            const localHeight = waveFunction(phase, localAmplitude);\r\n\r\n            const rotatedNormal = normalRotation(normal);\r\n            const dX = localHeight * rotatedNormal.x;\r\n            const dY = localHeight * rotatedNormal.y;\r\n\r\n            const absolutePoint = imageFitting.relativeToAbsolute(point);\r\n            plotter.addPointToLine(absolutePoint.x + dX, absolutePoint.y + dY);\r\n\r\n            const localFrequency = localDarkness * maxFrequency;\r\n            phase += localFrequency * step;\r\n        });\r\n\r\n        if (plotter.hasStartedALine) {\r\n            plotter.endLine();\r\n        }\r\n    }\r\n\r\n    plotter.finalize();\r\n    console.log(`Plotting took ${performance.now() - start} ms.`);\r\n}\r\n\r\nlet inputImage: InputImage = null;\r\nconst canvasPlotter = new PlotterCanvas2D();\r\n\r\nfunction plotOnCanvas(): void {\r\n    plot(inputImage, canvasPlotter);\r\n}\r\nParameters.addRedrawObserver(plotOnCanvas);\r\n\r\nfunction updateBlur(blur: number): void {\r\n    canvasPlotter.blur = blur;\r\n}\r\nParameters.addBlurChangeObserver(updateBlur);\r\nupdateBlur(Parameters.blur);\r\n\r\nParameters.addDownloadObserver(() => {\r\n    const svgPlotter = new PlotterSVG();\r\n    plot(inputImage, svgPlotter);\r\n    const svgString = svgPlotter.export();\r\n    const filename = \"image-as-sines.svg\";\r\n    Helpers.downloadTextFile(svgString, filename);\r\n});\r\n\r\nfunction onImageLoad(image: HTMLImageElement): void {\r\n    inputImage = new InputImage(image);\r\n    Page.Canvas.showLoader(false);\r\n    plotOnCanvas();\r\n}\r\nParameters.addFileUploadObserver(onImageLoad);\r\n\r\nPage.Canvas.showLoader(true);\r\nconst defaultImage = new Image();\r\ndefaultImage.addEventListener(\"load\", () => {\r\n    onImageLoad(defaultImage);\r\n});\r\ndefaultImage.src = \"./resources/cat.jpg\";\r\n","import \"./page-interface-generated\";\r\n\r\nconst controlId = {\r\n    UPLOAD_INPUT_IMAGE: \"input-image-upload-button\",\r\n    LINES_TYPE: \"lines-type-tabs-id\",\r\n    LINES_COUNT: \"lines-count-range-id\",\r\n    ORIENTATION: \"orientation-range-id\",\r\n    LINES_SIDES: \"lines-sides-range-id\",\r\n    LINES_AMPLITUDE: \"lines-amplitude-range-id\",\r\n    LINES_FREQUENCY: \"lines-frequency-range-id\",\r\n    AMPLITUDE: \"max-amplitude-range-id\",\r\n    FREQUENCY: \"max-frequency-range-id\",\r\n    ANGLE: \"angle-range-id\",\r\n    WAVE_SQUARENESS: \"wave-squareness-range-id\",\r\n    LINE_THICKNESS: \"line-thickness-range-id\",\r\n    ROUND_LINECAP: \"round-linecap-checkbox-id\",\r\n    INVERT_COLORS: \"invert-colors-checkbox-id\",\r\n    BLUR: \"blur-range-id\",\r\n    TRUE_INTENSITY: \"true-intensity-checkbox-id\",\r\n    DOWNLOAD: \"result-download-id\",\r\n};\r\n\r\nenum ELinesType {\r\n    STRAIGHT = \"0\",\r\n    SPIRAL = \"1\",\r\n    POLYGON = \"2\",\r\n    SINES = \"3\",\r\n}\r\n\r\ntype RedrawObserver = () => unknown;\r\nconst redrawObservers: RedrawObserver[] = [];\r\nfunction triggerRedraw(): void {\r\n    for (const observer of redrawObservers) {\r\n        observer();\r\n    }\r\n}\r\n\r\nPage.Tabs.addObserver(controlId.LINES_TYPE, triggerRedraw);\r\nPage.Range.addLazyObserver(controlId.LINES_COUNT, triggerRedraw);\r\nPage.Range.addLazyObserver(controlId.ORIENTATION, triggerRedraw);\r\nPage.Range.addLazyObserver(controlId.LINES_SIDES, triggerRedraw);\r\nPage.Range.addLazyObserver(controlId.LINES_AMPLITUDE, triggerRedraw);\r\nPage.Range.addLazyObserver(controlId.LINES_FREQUENCY, triggerRedraw);\r\nPage.Range.addLazyObserver(controlId.AMPLITUDE, triggerRedraw);\r\nPage.Range.addLazyObserver(controlId.FREQUENCY, triggerRedraw);\r\nPage.Range.addLazyObserver(controlId.ANGLE, triggerRedraw);\r\nPage.Range.addLazyObserver(controlId.WAVE_SQUARENESS, triggerRedraw);\r\nPage.Range.addLazyObserver(controlId.LINE_THICKNESS, triggerRedraw);\r\nPage.Checkbox.addObserver(controlId.ROUND_LINECAP, triggerRedraw);\r\nPage.Checkbox.addObserver(controlId.INVERT_COLORS, triggerRedraw);\r\nPage.Checkbox.addObserver(controlId.TRUE_INTENSITY, triggerRedraw);\r\nPage.Canvas.Observers.canvasResize.push(triggerRedraw);\r\n\r\nfunction udpateLinesControlsVisibility(): void {\r\n    const type = Page.Tabs.getValues(controlId.LINES_TYPE)[0] as ELinesType;\r\n    Page.Controls.setVisibility(controlId.LINES_SIDES, type === ELinesType.POLYGON);\r\n    Page.Controls.setVisibility(controlId.LINES_AMPLITUDE, type === ELinesType.SINES);\r\n    Page.Controls.setVisibility(controlId.LINES_FREQUENCY, type === ELinesType.SINES);\r\n}\r\nPage.Tabs.addObserver(controlId.LINES_TYPE, udpateLinesControlsVisibility);\r\nudpateLinesControlsVisibility();\r\n\r\nabstract class Parameters {\r\n    public static addFileUploadObserver(callback: (image: HTMLImageElement) => unknown): void {\r\n        Page.FileControl.addUploadObserver(controlId.UPLOAD_INPUT_IMAGE, (filesList: FileList) => {\r\n            if (filesList.length === 1) {\r\n                Page.Canvas.showLoader(true);\r\n                const reader = new FileReader();\r\n                reader.onload = () => {\r\n                    const image = new Image();\r\n                    image.addEventListener(\"load\", () => {\r\n                        callback(image);\r\n                    })\r\n                    image.src = reader.result as string;\r\n                };\r\n                reader.readAsDataURL(filesList[0]);\r\n            }\r\n        });\r\n    }\r\n\r\n    public static get linesType(): ELinesType {\r\n        return Page.Tabs.getValues(controlId.LINES_TYPE)[0] as ELinesType;\r\n    }\r\n\r\n    public static get linesCount(): number {\r\n        return Page.Range.getValue(controlId.LINES_COUNT);\r\n    }\r\n\r\n    public static get orientationInDegrees(): number {\r\n        return Page.Range.getValue(controlId.ORIENTATION);\r\n    }\r\n    public static get orientationInRadians(): number {\r\n        return this.orientationInDegrees / 180 * Math.PI;\r\n    }\r\n\r\n    public static get linesSides(): number {\r\n        return Page.Range.getValue(controlId.LINES_SIDES);\r\n    }\r\n\r\n    public static get linesAmplitude(): number {\r\n        return Page.Range.getValue(controlId.LINES_AMPLITUDE);\r\n    }\r\n\r\n    public static get linesFrequency(): number {\r\n        return Page.Range.getValue(controlId.LINES_FREQUENCY);\r\n    }\r\n\r\n    public static get maxAmplitude(): number {\r\n        return Page.Range.getValue(controlId.AMPLITUDE);\r\n    }\r\n\r\n    public static get maxFrequency(): number {\r\n        return Page.Range.getValue(controlId.FREQUENCY);\r\n    }\r\n\r\n    public static get angle(): number {\r\n        return Page.Range.getValue(controlId.ANGLE);\r\n    }\r\n\r\n    public static get waveSquareness(): number {\r\n        return Page.Range.getValue(controlId.WAVE_SQUARENESS);\r\n    }\r\n\r\n    public static get lineThickness(): number {\r\n        return Page.Range.getValue(controlId.LINE_THICKNESS);\r\n    }\r\n\r\n    public static get roundLinecap(): boolean {\r\n        return Page.Checkbox.isChecked(controlId.ROUND_LINECAP);\r\n    }\r\n\r\n    public static get invertColors(): boolean {\r\n        return Page.Checkbox.isChecked(controlId.INVERT_COLORS);\r\n    }\r\n\r\n    public static get trueIntensity(): boolean {\r\n        return Page.Checkbox.isChecked(controlId.TRUE_INTENSITY);\r\n    }\r\n\r\n\r\n    public static addRedrawObserver(callback: RedrawObserver): void {\r\n        redrawObservers.push(callback);\r\n    }\r\n\r\n    public static get blur(): number {\r\n        return Page.Range.getValue(controlId.BLUR);\r\n    }\r\n    public static addBlurChangeObserver(callback: (newBlur: number) => unknown): void {\r\n        Page.Range.addObserver(controlId.BLUR, callback);\r\n    }\r\n\r\n    public static addDownloadObserver(callback: () => unknown): void {\r\n        Page.FileControl.addDownloadObserver(controlId.DOWNLOAD, callback);\r\n    }\r\n}\r\n\r\nexport { Parameters, ELinesType }\r\n","import { IPoint } from \"../interfaces/i-point\";\r\nimport { ISize } from \"../interfaces/i-size\";\r\n\r\ninterface IPlotterInfo {\r\n    backgroundColor: string;\r\n    lineColor: string;\r\n    lineThickness: number;\r\n    blur: number;\r\n}\r\n\r\ninterface IImageFitting {\r\n    sizeInPlotter: ISize,\r\n    relativeToAbsolute: (relativeCoords: IPoint) => IPoint;\r\n    zoomFactor: number,\r\n};\r\n\r\nconst ANGLE_THRESHOLD = Math.PI * 0.01;\r\n\r\nabstract class PlotterBase {\r\n    public abstract initialize(infos: IPlotterInfo): void;\r\n    public abstract finalize(): void;\r\n\r\n    public get hasStartedALine(): boolean {\r\n        return this._hasStartedALine;\r\n    }\r\n\r\n    public startLine(): void {\r\n        this._hasStartedALine = true;\r\n        this.startLineInternal();\r\n\r\n        this.lastDrawnPoint = null;\r\n        this.potentialNextPoint = null;\r\n    }\r\n\r\n    public addPointToLine(x: number, y: number): void {\r\n        const newPoint: IPoint = { x, y };\r\n\r\n        if (this.lastDrawnPoint === null) {\r\n            this.lastDrawnPoint = newPoint;\r\n            this.addFirstPointToLineInternal(this.lastDrawnPoint.x, this.lastDrawnPoint.y);\r\n        } else if (this.potentialNextPoint === null) {\r\n            this.potentialNextPoint = newPoint;\r\n        } else {\r\n            const angle = PlotterBase.computeAngle(this.lastDrawnPoint, this.potentialNextPoint, newPoint);\r\n\r\n            if (angle > ANGLE_THRESHOLD) {\r\n                this.addPointToLineInternal(this.potentialNextPoint.x, this.potentialNextPoint.y); // this point cannot be skipped because it defines a significant angle\r\n                this.lastDrawnPoint = this.potentialNextPoint;\r\n            }\r\n            this.potentialNextPoint = newPoint;\r\n        }\r\n    }\r\n\r\n    public endLine(): void {\r\n        if (this.potentialNextPoint !== null) {\r\n            this.addPointToLineInternal(this.potentialNextPoint.x, this.potentialNextPoint.y);\r\n        }\r\n        this.lastDrawnPoint = null;\r\n        this.potentialNextPoint = null;\r\n\r\n        this.endLineInternal();\r\n        this._hasStartedALine = false;\r\n    }\r\n\r\n    public fitImage(imageAspectRatio: number): IImageFitting {\r\n        const plotterSize = this.size;\r\n        const displayAspectRatio = plotterSize.width / plotterSize.height;\r\n\r\n        const sizeInPlotter: ISize = {\r\n            width: plotterSize.width,\r\n            height: plotterSize.height,\r\n        };\r\n        if (imageAspectRatio > displayAspectRatio) {\r\n            sizeInPlotter.height = Math.floor(sizeInPlotter.height * displayAspectRatio / imageAspectRatio);\r\n        } else if (imageAspectRatio < displayAspectRatio) {\r\n            sizeInPlotter.width = Math.floor(sizeInPlotter.width * imageAspectRatio / displayAspectRatio);\r\n        }\r\n\r\n        const offSetX = 0.5 * (plotterSize.width - sizeInPlotter.width);\r\n        const offSetY = 0.5 * (plotterSize.height - sizeInPlotter.height);\r\n        const relativeToAbsolute = (relativeCoords: IPoint): IPoint => {\r\n            return {\r\n                x: relativeCoords.x + offSetX,\r\n                y: relativeCoords.y + offSetY,\r\n            };\r\n        };\r\n\r\n        const minSide = Math.min(sizeInPlotter.width, sizeInPlotter.height);\r\n        const baseMinSide = Math.min(imageAspectRatio, 1 / imageAspectRatio);\r\n\r\n        return {\r\n            sizeInPlotter,\r\n            relativeToAbsolute,\r\n            zoomFactor: minSide / baseMinSide,\r\n        };\r\n    }\r\n\r\n    protected abstract get size(): ISize;\r\n    protected abstract startLineInternal(): void;\r\n    protected abstract addFirstPointToLineInternal(x: number, y: number): void;\r\n    protected abstract addPointToLineInternal(x: number, y: number): void;\r\n    protected abstract endLineInternal(): void;\r\n\r\n    /** Smallest absolute angle difference between vectors p2-p1 and p3-p2 */\r\n    private static computeAngle(p1: IPoint, p2: IPoint, p3: IPoint): number {\r\n        const angle1 = Math.atan2(p2.y - p1.y, p2.x - p1.x); // in [-PI,PI] (warped)\r\n        const angle2 = Math.atan2(p3.y - p2.y, p3.x - p2.x); // in [-PI,PI] (warped)\r\n\r\n        const diffAngle = Math.abs(angle1 - angle2); // in [0, 2 * PI] (warped)\r\n        return Math.min(diffAngle, 2 * Math.PI - diffAngle);\r\n    }\r\n\r\n    private lastDrawnPoint: IPoint;\r\n    private potentialNextPoint: IPoint;\r\n    private _hasStartedALine: boolean = false;\r\n}\r\n\r\nexport { PlotterBase, IPlotterInfo, ISize }\r\n","import { PlotterBase, IPlotterInfo, ISize } from \"./plotter-base\";\r\n\r\nimport \"../page-interface-generated\";\r\nimport { Parameters } from \"../parameters\";\r\n\r\nclass PlotterCanvas2D extends PlotterBase {\r\n    private readonly canvas: HTMLCanvasElement;\r\n    private readonly context: CanvasRenderingContext2D;\r\n    private readonly cssPixel: number;\r\n\r\n    public constructor() {\r\n        super();\r\n\r\n        this.canvas = Page.Canvas.getCanvas();\r\n        this.context = this.canvas.getContext(\"2d\", { alpha: false });\r\n        this.cssPixel = window.devicePixelRatio ?? 1;\r\n    }\r\n\r\n    public initialize(infos: IPlotterInfo): void {\r\n        this.resizeCanvas();\r\n\r\n        this.context.fillStyle = infos.backgroundColor;\r\n        this.context.strokeStyle = infos.lineColor;\r\n        this.context.lineWidth = infos.lineThickness * this.cssPixel;\r\n        this.context.lineJoin = \"round\";\r\n        this.context.lineCap = Parameters.roundLinecap ? \"round\" : \"butt\";\r\n        this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);\r\n    }\r\n\r\n    // tslint:disable-next-line:no-empty\r\n    public finalize(): void { }\r\n\r\n    public set blur(value: number) {\r\n        if (value === 0) {\r\n            this.canvas.style.filter = \"\";\r\n        } else {\r\n            this.canvas.style.filter = `blur(${value}px)`;\r\n        }\r\n    }\r\n\r\n    protected get size(): ISize {\r\n        return {\r\n            width: Math.floor(this.canvas.width / this.cssPixel),\r\n            height: Math.floor(this.canvas.height / this.cssPixel),\r\n        };\r\n    }\r\n\r\n    protected startLineInternal(): void {\r\n        this.context.beginPath();\r\n    }\r\n\r\n    protected addFirstPointToLineInternal(rawX: number, rawY: number): void {\r\n        const x = rawX * this.cssPixel;\r\n        const y = rawY * this.cssPixel;\r\n        this.context.moveTo(x, y);\r\n    }\r\n\r\n    protected addPointToLineInternal(rawX: number, rawY: number): void {\r\n        const x = rawX * this.cssPixel;\r\n        const y = rawY * this.cssPixel;\r\n        this.context.lineTo(x, y);\r\n    }\r\n\r\n    protected endLineInternal(): void {\r\n        this.context.stroke();\r\n        this.context.closePath();\r\n    }\r\n\r\n    private resizeCanvas(): void {\r\n        const actualWidth = Math.floor(this.cssPixel * this.canvas.clientWidth);\r\n        const actualHeight = Math.floor(this.cssPixel * this.canvas.clientHeight);\r\n\r\n        if (this.canvas.width !== actualWidth || this.canvas.height !== actualHeight) {\r\n            this.canvas.width = actualWidth;\r\n            this.canvas.height = actualHeight;\r\n        }\r\n    }\r\n}\r\n\r\nexport { PlotterCanvas2D }\r\n","import { Parameters } from \"../parameters\";\r\nimport { PlotterBase, IPlotterInfo, ISize } from \"./plotter-base\";\r\n\r\nconst WIDTH = 1000;\r\nconst HEIGHT = 1000;\r\n\r\nclass PlotterSVG extends PlotterBase {\r\n    private stringParts: string[];\r\n    private hasBlur: boolean;\r\n\r\n    public constructor() {\r\n        super();\r\n    }\r\n\r\n    public initialize(infos: IPlotterInfo): void {\r\n        this.hasBlur = infos.blur > 0;\r\n\r\n        this.stringParts = [];\r\n\r\n        this.stringParts.push(`<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\\n`);\r\n        this.stringParts.push(`<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" viewBox=\"0 0 ${WIDTH} ${HEIGHT}\">\\n`);\r\n\r\n        if (this.hasBlur) {\r\n            const blurEffectId = \"gaussianBlur\";\r\n\r\n            this.stringParts.push(`\\t<defs>\\n`);\r\n            this.stringParts.push(`\\t\\t<filter id=\"${blurEffectId}\" x=\"0\" y=\"0\">\\n`);\r\n            this.stringParts.push(`\\t\\t\\t<feGaussianBlur in=\"SourceGraphic\" stdDeviation=\"${infos.blur}\"/>\\n`);\r\n            this.stringParts.push(`\\t\\t</filter>\\n`);\r\n            this.stringParts.push(`\\t</defs>\\n`);\r\n            this.stringParts.push(`\\t<g filter=\"url(#${blurEffectId})\">\\n`);\r\n        }\r\n\r\n        this.stringParts.push(`\\t<rect fill=\"${infos.backgroundColor}\" stroke=\"none\" x=\"0\" y=\"0\" width=\"${WIDTH}\" height=\"${HEIGHT}\"/>\\n`);\r\n        const linecap = Parameters.roundLinecap ? ` stroke-linecap=\"round\"` : ``;\r\n        this.stringParts.push(`\\t<g fill=\"none\" stroke=\"${infos.lineColor}\" stroke-width=\"${infos.lineThickness}\" stroke-linejoin=\"round\"${linecap}>\\n`);\r\n    }\r\n\r\n    // tslint:disable-next-line:no-empty\r\n    public finalize(): void {\r\n        if (this.hasBlur) {\r\n            this.stringParts.push(`\\t\\t</g>\\n`);\r\n        }\r\n\r\n        this.stringParts.push(`\\t</g>\\n`);\r\n        this.stringParts.push(`</svg>\\n`);\r\n    }\r\n\r\n    public endLineInternal(): void {\r\n        this.stringParts.push(`\"/>\\n`);\r\n    }\r\n\r\n    public export(): string {\r\n        const start = Date.now();\r\n        const result = this.stringParts.join(\"\");\r\n        console.log(`Concatenation took ${Date.now() - start} ms.`);\r\n        return result;\r\n    }\r\n\r\n    protected get size(): ISize {\r\n        return {\r\n            width: WIDTH,\r\n            height: HEIGHT,\r\n        };\r\n    }\r\n\r\n    protected startLineInternal(): void {\r\n        this.stringParts.push(`\\t\\t<path d=\"`);\r\n    }\r\n\r\n    protected addFirstPointToLineInternal(rawX: number, rawY: number): void {\r\n        const x = rawX.toFixed(1);\r\n        const y = rawY.toFixed(1);\r\n        this.stringParts.push(`M${x},${y}L`);\r\n    }\r\n\r\n    protected addPointToLineInternal(rawX: number, rawY: number): void {\r\n        const x = rawX.toFixed(1);\r\n        const y = rawY.toFixed(1);\r\n        this.stringParts.push(`${x},${y} `);\r\n    }\r\n}\r\n\r\nexport { PlotterSVG }\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module\n// This entry module is referenced by other modules so it can't be inlined\n__webpack_require__(633);\n"],"sourceRoot":""}