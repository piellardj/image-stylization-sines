{"version":3,"sources":["webpack://image-stylization-sines/./src/ts/helpers.ts","webpack://image-stylization-sines/./src/ts/input-image.ts","webpack://image-stylization-sines/./src/ts/interfaces/i-point.ts","webpack://image-stylization-sines/./src/ts/main.ts","webpack://image-stylization-sines/./src/ts/parameters.ts","webpack://image-stylization-sines/./src/ts/pattern/pattern-base.ts","webpack://image-stylization-sines/./src/ts/pattern/pattern-polygon.ts","webpack://image-stylization-sines/./src/ts/pattern/pattern-spiral.ts","webpack://image-stylization-sines/./src/ts/pattern/pattern-straight-lines.ts","webpack://image-stylization-sines/./src/ts/plotter/plotter-base.ts","webpack://image-stylization-sines/./src/ts/plotter/plotter-canvas-2d.ts","webpack://image-stylization-sines/./src/ts/plotter/plotter-svg.ts","webpack://image-stylization-sines/webpack/bootstrap","webpack://image-stylization-sines/webpack/startup"],"names":["buildPlotterInfos","backgroundColor","Parameters","invertColors","lineColor","lineThickness","blur","fitImageInPlotter","maxSize","aspectRatio","displayAspectRatio","width","height","sizeInPlotter","Math","floor","offSetX","offSetY","relativeToAbsolute","relativeCoords","x","y","zoomFactor","min","chooseBestSamplingFunction","trueIntensity","inputImage","coords","sqrt","sample","computeNormalRotationFunction","angle","PI","cosAngle","cos","sinAngle","sin","lengthAdjustment","normal","computeWaveFunction","waveSquareness","phase","amplitude","sharpness","sinPhase","sign","pow","abs","choosePattern","imageSizeInPlotter","linesSpacing","chosenPattern","linesPattern","ELinesPattern","STRAIGHT","PatternStraightLines","SPIRAL","PatternSpiral","PatternPolygon","image","this","hiddenCanvas","document","createElement","hiddenContext","getContext","sourceImage","_size","resize","wantedSize","wantedWidth","wantedHeight","console","log","drawImage","fullPixelsArray","getImageData","data","valueArray","Uint8ClampedArray","i","length","r","g","b","normalizedCoords","pixelCoords","floorPixelCoords","fractPixelCoords","topLeft","getPixel","topRight","bottomLeft","bottomRight","top","interpolate","bottom","a","InputImage","distance","dX","dY","rotate","p","plot","plotter","start","Date","now","displayInfos","Helpers","initialize","plotterSize","size","imageFitting","sourceImageAspectRatio","linesCount","maxFrequency","maxAmplitude","pattern","suggestedImageSize","samplingFunction","normalRotation","waveFunction","step","max","iLine","walkOnLine","point","hasStartedALine","endLine","startLine","localDarkness","localHeight","rotatedNormal","absolutePoint","addPointToLine","nbLines","finalize","canvasPlotter","PlotterCanvas2D","plotOnCanvas","updateBlur","onImageLoad","Page","Canvas","showLoader","addRedrawObserver","addBlurChangeObserver","addDownloadObserver","svgPlotter","PlotterSVG","fileName","fileType","svgString","export","blob","Blob","type","window","navigator","msSaveBlob","URL","createObjectURL","linkElement","download","href","dataset","downloadurl","style","display","body","appendChild","click","removeChild","setTimeout","revokeObjectURL","addFileUploadObserver","defaultImage","Image","addEventListener","src","controlId","redrawObservers","triggerRedraw","observer","udpateLinesSidesVisibility","Tabs","getValues","Controls","setVisibility","POLYGON","addObserver","Range","addLazyObserver","Checkbox","Observers","canvasResize","push","callback","FileControl","addUploadObserver","filesList","FileReader","onload","result","readAsDataURL","getValue","orientationInDegrees","isChecked","PatternBase","imageSize","_center","_suggestedImageSize","_linesSpacing","_nbSides","linesSides","diagonal","_maxSegments","ceil","_lineId","insideAngle","dSideLength","tan","startSideLength","startPoint","iSide","sideLength","tangentAngle","endPoint","segmentLength","iSubstep","progression","_radiusGap","nbSemiCircles","_maxAngle","orientation","orientationInRadians","cosOrientation","sinOrientation","semiCircleId","radius","centerOffset","ELinesOrientation","_normal","linesOrientation","DIAGONAL","VERTICAL","HORIZONTAL","_lines","computeLine","maxAbsLine","computeMaximumLinesNeeded","iAbsLine","line","xOutOfBounds","yOutOfBounds","computeBestImageSize","lineId","computePoint","completion","end","maxNbSteps","iStep","tangent","maxX","maxY","startAdjustment","endAdjustment","ANGLE_THRESHOLD","_hasStartedALine","startLineInternal","lastDrawnPoint","potentialNextPoint","newPoint","addFirstPointToLineInternal","PlotterBase","computeAngle","addPointToLineInternal","endLineInternal","p1","p2","p3","angle1","atan2","angle2","diffAngle","canvas","getCanvas","context","alpha","cssPixel","devicePixelRatio","infos","resizeCanvas","fillStyle","strokeStyle","lineWidth","fillRect","value","filter","beginPath","rawX","rawY","moveTo","lineTo","stroke","closePath","actualWidth","clientWidth","actualHeight","clientHeight","hasBlur","stringParts","join","toFixed","__webpack_module_cache__","__webpack_require__","moduleId","exports","module","__webpack_modules__","call"],"mappings":"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","file":"main.min.js","sourcesContent":["import { InputImage } from \"./input-image\";\r\nimport { IPoint } from \"./interfaces/i-point\";\r\nimport { ISize } from \"./interfaces/i-size\";\r\nimport { Parameters, ELinesPattern } from \"./parameters\";\r\nimport { PatternBase } from \"./pattern/pattern-base\";\r\nimport { PatternStraightLines } from \"./pattern/pattern-straight-lines\";\r\nimport { PatternSpiral } from \"./pattern/pattern-spiral\";\r\nimport { IPlotterInfo } from \"./plotter/plotter-base\";\r\nimport { PatternPolygon } from \"./pattern/pattern-polygon\";\r\n\r\nfunction buildPlotterInfos(): IPlotterInfo {\r\n    return {\r\n        backgroundColor: Parameters.invertColors ? \"black\" : \"white\",\r\n        lineColor: Parameters.invertColors ? \"white\" : \"black\",\r\n        lineThickness: Parameters.lineThickness,\r\n        blur: Parameters.blur,\r\n    };\r\n}\r\n\r\ninterface IImageFitting {\r\n    sizeInPlotter: ISize,\r\n    relativeToAbsolute: (relativeCoords: IPoint) => IPoint;\r\n    zoomFactor: number,\r\n};\r\n\r\nfunction fitImageInPlotter(maxSize: ISize, aspectRatio: number): IImageFitting {\r\n    const displayAspectRatio = maxSize.width / maxSize.height;\r\n\r\n    const sizeInPlotter: ISize = {\r\n        width: maxSize.width,\r\n        height: maxSize.height,\r\n    };\r\n    if (aspectRatio > displayAspectRatio) {\r\n        sizeInPlotter.height = Math.floor(sizeInPlotter.height * displayAspectRatio / aspectRatio);\r\n    } else if (aspectRatio < displayAspectRatio) {\r\n        sizeInPlotter.width = Math.floor(sizeInPlotter.width * aspectRatio / displayAspectRatio);\r\n    }\r\n\r\n    const offSetX = 0.5 * (maxSize.width - sizeInPlotter.width);\r\n    const offSetY = 0.5 * (maxSize.height - sizeInPlotter.height);\r\n    const relativeToAbsolute = (relativeCoords: IPoint): IPoint => {\r\n        return {\r\n            x: relativeCoords.x + offSetX,\r\n            y: relativeCoords.y + offSetY,\r\n        };\r\n    };\r\n\r\n    const minSide = Math.min(sizeInPlotter.width, sizeInPlotter.height);\r\n    const baseMinSide = Math.min(aspectRatio, 1 / aspectRatio);\r\n\r\n    return {\r\n        sizeInPlotter,\r\n        relativeToAbsolute,\r\n        zoomFactor: minSide / baseMinSide,\r\n    };\r\n}\r\n\r\ntype SamplingFunction = (inputImage: InputImage, coords: IPoint) => number;\r\nfunction chooseBestSamplingFunction(): SamplingFunction {\r\n    if (Parameters.trueIntensity) {\r\n        if (Parameters.invertColors) {\r\n            return (inputImage: InputImage, coords: IPoint) => Math.sqrt(inputImage.sample(coords));\r\n        } else {\r\n            return (inputImage: InputImage, coords: IPoint) => Math.sqrt(1.001 - inputImage.sample(coords));\r\n        }\r\n    } else {\r\n        if (Parameters.invertColors) {\r\n            return (inputImage: InputImage, coords: IPoint) => inputImage.sample(coords);\r\n        } else {\r\n            return (inputImage: InputImage, coords: IPoint) => 1 - inputImage.sample(coords);\r\n        }\r\n    }\r\n}\r\n\r\ntype NormalRotationFunction = (normal: IPoint) => IPoint;\r\nfunction computeNormalRotationFunction(): NormalRotationFunction {\r\n    const angle = Parameters.angle * 2 * Math.PI;\r\n    const cosAngle = Math.cos(angle);\r\n    const sinAngle = Math.sin(angle);\r\n    const lengthAdjustment = 1 / cosAngle; // to maintain the waves height no matter the angle\r\n    return (normal: IPoint): IPoint => {\r\n        return {\r\n            x: (cosAngle * normal.x - sinAngle * normal.y) * lengthAdjustment,\r\n            y: (sinAngle * normal.x + cosAngle * normal.y) * lengthAdjustment,\r\n        };\r\n    };\r\n}\r\n\r\ntype WaveFunction = (phase: number, amplitude: number) => number;\r\nfunction computeWaveFunction(): WaveFunction {\r\n    if (Parameters.waveSquareness < 0.005) {\r\n        return (phase: number, amplitude: number) => amplitude * Math.sin(phase);\r\n    }\r\n\r\n    const sharpness = 1 - 0.99 * Parameters.waveSquareness;\r\n    return (phase: number, amplitude: number) => {\r\n        const sinPhase = Math.sin(phase);\r\n        return amplitude * Math.sign(sinPhase) * Math.pow(Math.abs(sinPhase), sharpness);\r\n    };\r\n}\r\n\r\nfunction choosePattern(imageSizeInPlotter: ISize, linesSpacing: number): PatternBase {\r\n    const chosenPattern = Parameters.linesPattern;\r\n    if (chosenPattern === ELinesPattern.STRAIGHT) {\r\n        return new PatternStraightLines(imageSizeInPlotter, linesSpacing);\r\n    } else if (chosenPattern === ELinesPattern.SPIRAL) {\r\n        return new PatternSpiral(imageSizeInPlotter, linesSpacing);\r\n    } else {\r\n        return new PatternPolygon(imageSizeInPlotter, linesSpacing);\r\n    }\r\n}\r\n\r\nexport {\r\n    buildPlotterInfos,\r\n    chooseBestSamplingFunction,\r\n    choosePattern,\r\n    computeNormalRotationFunction,\r\n    computeWaveFunction,\r\n    fitImageInPlotter,\r\n};\r\n","import { ISize } from \"./interfaces/i-size\";\r\nimport { IPoint } from \"./interfaces/i-point\";\r\n\r\nclass InputImage {\r\n    private _size: ISize;\r\n\r\n    private readonly hiddenCanvas: HTMLCanvasElement;\r\n    private readonly hiddenContext: CanvasRenderingContext2D;\r\n    private readonly sourceImage: HTMLImageElement;\r\n    private valueArray: Uint8ClampedArray;\r\n\r\n    public constructor(image: HTMLImageElement) {\r\n        this.hiddenCanvas = document.createElement(\"canvas\");\r\n        this.hiddenContext = this.hiddenCanvas.getContext(\"2d\");\r\n        this.sourceImage = image;\r\n        this._size = {\r\n            width: 0,\r\n            height: 0,\r\n        };\r\n\r\n        this.resize({ width: image.width, height: image.height });\r\n    }\r\n\r\n    public get size(): ISize {\r\n        return this._size;\r\n    }\r\n\r\n    public get width(): number {\r\n        return this._size.width;\r\n    }\r\n\r\n    public get height(): number {\r\n        return this._size.height;\r\n    }\r\n\r\n    public get sourceImageAspectRatio(): number {\r\n        return this.sourceImage.width / this.sourceImage.height;\r\n    }\r\n\r\n    public resize(wantedSize: ISize): void {\r\n        // the canvas handles image downsizing, however upsizing is handled manually in the sample method.\r\n        const wantedWidth = Math.min(this.sourceImage.width, wantedSize.width);\r\n        const wantedHeight = Math.min(this.sourceImage.height, wantedSize.height);\r\n\r\n        if (this.width !== wantedWidth || this.height !== wantedHeight) {\r\n            console.log(`Resize image from ${this.width}x${this.height} to ${wantedWidth}x${wantedHeight}.`);\r\n\r\n            this._size.width = wantedWidth;\r\n            this._size.height = wantedHeight;\r\n\r\n            this.hiddenCanvas.width = this.width;\r\n            this.hiddenCanvas.height = this.height;\r\n            this.hiddenContext.drawImage(this.sourceImage, 0, 0, this.width, this.height);\r\n\r\n            // retrieve all pixels at once because it is way faster that 1 by 1\r\n            const fullPixelsArray = this.hiddenContext.getImageData(0, 0, this.width, this.height).data;\r\n            this.valueArray = new Uint8ClampedArray(this.width * this.height);\r\n\r\n            for (let i = 0; i < this.valueArray.length; i++) {\r\n                const r = fullPixelsArray[4 * i];\r\n                const g = fullPixelsArray[4 * i + 1];\r\n                const b = fullPixelsArray[4 * i + 2];\r\n                this.valueArray[i] = (r + g + b) / 3;\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Returns a value in [0, 1]. Performs linear interpolation. */\r\n    public sample(normalizedCoords: IPoint): number {\r\n        const pixelCoords: IPoint = {\r\n            x: normalizedCoords.x * (this._size.width - 1),\r\n            y: normalizedCoords.y * (this._size.height - 1),\r\n        }\r\n\r\n        const floorPixelCoords: IPoint = {\r\n            x: Math.floor(pixelCoords.x),\r\n            y: Math.floor(pixelCoords.y),\r\n        };\r\n        const fractPixelCoords: IPoint = {\r\n            x: pixelCoords.x - floorPixelCoords.x,\r\n            y: pixelCoords.y - floorPixelCoords.y,\r\n        };\r\n\r\n        const topLeft = this.getPixel(floorPixelCoords.x, floorPixelCoords.y);\r\n        const topRight = this.getPixel(floorPixelCoords.x + 1, floorPixelCoords.y);\r\n        const bottomLeft = this.getPixel(floorPixelCoords.x, floorPixelCoords.y + 1);\r\n        const bottomRight = this.getPixel(floorPixelCoords.x + 1, floorPixelCoords.y + 1);\r\n\r\n        const top = this.interpolate(topLeft, topRight, fractPixelCoords.x);\r\n        const bottom = this.interpolate(bottomLeft, bottomRight, fractPixelCoords.x);\r\n\r\n        const interpolated = this.interpolate(top, bottom, fractPixelCoords.y);\r\n\r\n        return interpolated / 255;\r\n    }\r\n\r\n    private interpolate(a: number, b: number, x: number): number {\r\n        return a * (1 - x) + b * x;\r\n    }\r\n\r\n    /** Returns a value in [0, 255]. No interpolation.\r\n     * @param x in pixels, must be an integer\r\n     * @param y in pixels, must be an integer\r\n     */\r\n    private getPixel(x: number, y: number): number {\r\n        if (x < 0 || y < 0 || x >= this.width || y >= this.height) {\r\n            return 0;\r\n        }\r\n\r\n        return this.valueArray[y * this.width + x];\r\n    }\r\n}\r\n\r\nexport { InputImage }\r\n","interface IPoint {\r\n    x: number;\r\n    y: number;\r\n}\r\n\r\nfunction distance(a: IPoint, b: IPoint): number {\r\n    const dX = a.x - b.x;\r\n    const dY = a.y - b.y;\r\n    return Math.sqrt(dX * dX + dY * dY);\r\n}\r\n\r\nfunction rotate(p: IPoint, angle: number): IPoint {\r\n    const cosAngle = Math.cos(angle);\r\n    const sinAngle = Math.sin(angle);\r\n\r\n    return {\r\n        x: p.x * cosAngle - p.y * sinAngle,\r\n        y: p.x * sinAngle + p.y * cosAngle,\r\n    };\r\n}\r\n\r\nexport { IPoint, distance, rotate }\r\n","import { Parameters } from \"./parameters\";\r\nimport { InputImage } from \"./input-image\";\r\n\r\nimport { IPoint } from \"./interfaces/i-point\";\r\n\r\nimport { PlotterBase } from \"./plotter/plotter-base\";\r\nimport { PlotterCanvas2D } from \"./plotter/plotter-canvas-2d\";\r\nimport { PlotterSVG } from \"./plotter/plotter-svg\";\r\n\r\nimport * as Helpers from \"./helpers\";\r\n\r\nimport \"./page-interface-generated\";\r\n\r\nfunction plot(image: InputImage, plotter: PlotterBase): void {\r\n    const start = Date.now();\r\n\r\n    if (image == null) {\r\n        console.log(\"Image not loaded!\");\r\n        return;\r\n    }\r\n\r\n    const displayInfos = Helpers.buildPlotterInfos();\r\n    plotter.initialize(displayInfos);\r\n\r\n    const plotterSize = plotter.size;\r\n    const imageFitting = Helpers.fitImageInPlotter(plotterSize, image.sourceImageAspectRatio);\r\n\r\n    const baseLineSpacing = 1 / Parameters.linesCount;\r\n    const linesSpacing = baseLineSpacing * imageFitting.zoomFactor;\r\n\r\n    const baseMaxFrequency = 500 * Parameters.maxFrequency;\r\n    const maxFrequency = baseMaxFrequency / imageFitting.zoomFactor;\r\n\r\n    const maxAmplitude = 0.5 * (linesSpacing - displayInfos.lineThickness) * Parameters.maxAmplitude;\r\n\r\n    const pattern = Helpers.choosePattern(imageFitting.sizeInPlotter, linesSpacing);\r\n\r\n    image.resize(pattern.suggestedImageSize);\r\n\r\n    const samplingFunction = Helpers.chooseBestSamplingFunction();\r\n    const normalRotation = Helpers.computeNormalRotationFunction();\r\n    const waveFunction = Helpers.computeWaveFunction();\r\n\r\n    const samplesPerPixel = Math.max(1, 2 * maxFrequency);\r\n    const step = 1 / samplesPerPixel;\r\n    for (let iLine = 0; iLine < pattern.nbLines; iLine++) {\r\n        let phase = 0;\r\n        pattern.walkOnLine(iLine, step, (point: IPoint, normal: IPoint) => {\r\n            const normalizedCoords: IPoint = {\r\n                x: point.x / (imageFitting.sizeInPlotter.width - 1),\r\n                y: point.y / (imageFitting.sizeInPlotter.height - 1),\r\n            };\r\n\r\n            const outOfImage = normalizedCoords.x < 0 || normalizedCoords.x > 1 || normalizedCoords.y < 0 || normalizedCoords.y > 1;\r\n            if (outOfImage) {\r\n                if (plotter.hasStartedALine) {\r\n                    plotter.endLine();\r\n                }\r\n                return;\r\n            } else if (!plotter.hasStartedALine) {\r\n                plotter.startLine();\r\n            }\r\n\r\n            const localDarkness = samplingFunction(inputImage, normalizedCoords);\r\n\r\n            const localAmplitude = localDarkness * maxAmplitude;\r\n            const localHeight = waveFunction(phase, localAmplitude);\r\n\r\n            const rotatedNormal = normalRotation(normal);\r\n            const dX = localHeight * rotatedNormal.x;\r\n            const dY = localHeight * rotatedNormal.y;\r\n\r\n            const absolutePoint = imageFitting.relativeToAbsolute(point);\r\n            plotter.addPointToLine(absolutePoint.x + dX, absolutePoint.y + dY);\r\n\r\n            const localFrequency = localDarkness * maxFrequency;\r\n            phase += localFrequency * step;\r\n        });\r\n\r\n        if (plotter.hasStartedALine) {\r\n            plotter.endLine();\r\n        }\r\n    }\r\n\r\n    plotter.finalize();\r\n    console.log(`Plotting took ${Date.now() - start} ms.`);\r\n}\r\n\r\nlet inputImage: InputImage = null;\r\n\r\nconst canvasPlotter = new PlotterCanvas2D();\r\nfunction plotOnCanvas(): void {\r\n    plot(inputImage, canvasPlotter);\r\n}\r\nParameters.addRedrawObserver(plotOnCanvas);\r\n\r\nfunction updateBlur(blur: number): void {\r\n    canvasPlotter.blur = blur;\r\n}\r\nParameters.addBlurChangeObserver(updateBlur);\r\nupdateBlur(Parameters.blur);\r\n\r\nParameters.addDownloadObserver(() => {\r\n    const svgPlotter = new PlotterSVG();\r\n    plot(inputImage, svgPlotter);\r\n\r\n    const fileName = \"image-as-sines.svg\";\r\n    const fileType = \"text/plain\";\r\n    const svgString = svgPlotter.export();\r\n\r\n    const blob = new Blob([svgString], { type: fileType });\r\n\r\n    if (typeof window.navigator !== \"undefined\" && typeof window.navigator.msSaveBlob !== \"undefined\") { // for IE\r\n        window.navigator.msSaveBlob(blob, fileName);\r\n    } else {\r\n        const objectUrl = URL.createObjectURL(blob);\r\n\r\n        const linkElement = document.createElement('a');\r\n        linkElement.download = fileName;\r\n        linkElement.href = objectUrl;\r\n        linkElement.dataset.downloadurl = `${fileType}:${linkElement.download}:${linkElement.href}`;\r\n        linkElement.style.display = \"none\";\r\n        document.body.appendChild(linkElement);\r\n        linkElement.click();\r\n        document.body.removeChild(linkElement);\r\n\r\n        // don't forget to free the objectURL after a few seconds\r\n        setTimeout(() => {\r\n            URL.revokeObjectURL(objectUrl);\r\n        }, 5000);\r\n    }\r\n});\r\n\r\nfunction onImageLoad(image: HTMLImageElement): void {\r\n    inputImage = new InputImage(image);\r\n    Page.Canvas.showLoader(false);\r\n    plotOnCanvas();\r\n}\r\nParameters.addFileUploadObserver(onImageLoad);\r\n\r\nPage.Canvas.showLoader(true);\r\nconst defaultImage = new Image();\r\ndefaultImage.addEventListener(\"load\", () => {\r\n    onImageLoad(defaultImage);\r\n});\r\ndefaultImage.src = \"./resources/cat.jpg\";\r\n","import \"./page-interface-generated\";\r\n\r\nconst controlId = {\r\n    UPLOAD_INPUT_IMAGE: \"input-image-upload-button\",\r\n    LINES_PATTERN: \"lines-pattern-style-tabs-id\",\r\n    LINES_COUNT: \"lines-count-range-id\",\r\n    ORIENTATION: \"orientation-range-id\",\r\n    LINES_SIDES: \"lines-sides-range-id\",\r\n    AMPLITUDE: \"max-amplitude-range-id\",\r\n    FREQUENCY: \"max-frequency-range-id\",\r\n    ANGLE: \"angle-range-id\",\r\n    WAVE_SQUARENESS: \"wave-squareness-range-id\",\r\n    LINE_THICKNESS: \"line-thickness-range-id\",\r\n    INVERT_COLORS: \"invert-colors-checkbox-id\",\r\n    BLUR: \"blur-range-id\",\r\n    TRUE_INTENSITY: \"true-intensity-checkbox-id\",\r\n    DOWNLOAD: \"result-download-id\",\r\n};\r\n\r\nenum ELinesPattern {\r\n    STRAIGHT = \"0\",\r\n    SPIRAL = \"1\",\r\n    POLYGON = \"2\",\r\n}\r\n\r\ntype RedrawObserver = () => unknown;\r\nconst redrawObservers: RedrawObserver[] = [];\r\nfunction triggerRedraw(): void {\r\n    for (const observer of redrawObservers) {\r\n        observer();\r\n    }\r\n}\r\n\r\nPage.Tabs.addObserver(controlId.LINES_PATTERN, triggerRedraw);\r\nPage.Range.addLazyObserver(controlId.LINES_COUNT, triggerRedraw);\r\nPage.Range.addLazyObserver(controlId.ORIENTATION, triggerRedraw);\r\nPage.Range.addLazyObserver(controlId.LINES_SIDES, triggerRedraw);\r\nPage.Range.addLazyObserver(controlId.AMPLITUDE, triggerRedraw);\r\nPage.Range.addLazyObserver(controlId.FREQUENCY, triggerRedraw);\r\nPage.Range.addLazyObserver(controlId.ANGLE, triggerRedraw);\r\nPage.Range.addLazyObserver(controlId.WAVE_SQUARENESS, triggerRedraw);\r\nPage.Range.addLazyObserver(controlId.LINE_THICKNESS, triggerRedraw);\r\nPage.Checkbox.addObserver(controlId.INVERT_COLORS, triggerRedraw);\r\nPage.Checkbox.addObserver(controlId.TRUE_INTENSITY, triggerRedraw);\r\nPage.Canvas.Observers.canvasResize.push(triggerRedraw);\r\n\r\nfunction udpateLinesSidesVisibility(): void {\r\n    const pattern = Page.Tabs.getValues(controlId.LINES_PATTERN)[0] as ELinesPattern;\r\n    Page.Controls.setVisibility(controlId.LINES_SIDES, pattern === ELinesPattern.POLYGON);\r\n}\r\nPage.Tabs.addObserver(controlId.LINES_PATTERN, udpateLinesSidesVisibility);\r\nudpateLinesSidesVisibility();\r\n\r\nabstract class Parameters {\r\n    public static addFileUploadObserver(callback: (image: HTMLImageElement) => unknown): void {\r\n        Page.FileControl.addUploadObserver(controlId.UPLOAD_INPUT_IMAGE, (filesList: FileList) => {\r\n            if (filesList.length === 1) {\r\n                Page.Canvas.showLoader(true);\r\n                const reader = new FileReader();\r\n                reader.onload = () => {\r\n                    const image = new Image();\r\n                    image.addEventListener(\"load\", () => {\r\n                        callback(image);\r\n                    })\r\n                    image.src = reader.result as string;\r\n                };\r\n                reader.readAsDataURL(filesList[0]);\r\n            }\r\n        });\r\n    }\r\n\r\n    public static get linesPattern(): ELinesPattern {\r\n        return Page.Tabs.getValues(controlId.LINES_PATTERN)[0] as ELinesPattern;\r\n    }\r\n\r\n    public static get linesCount(): number {\r\n        return Page.Range.getValue(controlId.LINES_COUNT);\r\n    }\r\n\r\n    public static get orientationInDegrees(): number {\r\n        return Page.Range.getValue(controlId.ORIENTATION);\r\n    }\r\n    public static get orientationInRadians(): number {\r\n        return this.orientationInDegrees / 180 * Math.PI;\r\n    }\r\n\r\n    public static get linesSides(): number {\r\n        return Page.Range.getValue(controlId.LINES_SIDES);\r\n    }\r\n\r\n    public static get maxAmplitude(): number {\r\n        return Page.Range.getValue(controlId.AMPLITUDE);\r\n    }\r\n\r\n    public static get maxFrequency(): number {\r\n        return Page.Range.getValue(controlId.FREQUENCY);\r\n    }\r\n\r\n    public static get angle(): number {\r\n        return Page.Range.getValue(controlId.ANGLE);\r\n    }\r\n\r\n    public static get waveSquareness(): number {\r\n        return Page.Range.getValue(controlId.WAVE_SQUARENESS);\r\n    }\r\n\r\n    public static get lineThickness(): number {\r\n        return Page.Range.getValue(controlId.LINE_THICKNESS);\r\n    }\r\n\r\n    public static get invertColors(): boolean {\r\n        return Page.Checkbox.isChecked(controlId.INVERT_COLORS);\r\n    }\r\n\r\n    public static get trueIntensity(): boolean {\r\n        return Page.Checkbox.isChecked(controlId.TRUE_INTENSITY);\r\n    }\r\n\r\n\r\n    public static addRedrawObserver(callback: RedrawObserver): void {\r\n        redrawObservers.push(callback);\r\n    }\r\n\r\n    public static get blur(): number {\r\n        return Page.Range.getValue(controlId.BLUR);\r\n    }\r\n    public static addBlurChangeObserver(callback: (newBlur: number) => unknown): void {\r\n        Page.Range.addObserver(controlId.BLUR, callback);\r\n    }\r\n\r\n    public static addDownloadObserver(callback: () => unknown): void {\r\n        Page.FileControl.addDownloadObserver(controlId.DOWNLOAD, callback);\r\n    }\r\n}\r\n\r\nexport { Parameters, ELinesPattern }\r\n","import { IPoint } from \"../interfaces/i-point\";\r\nimport { ISize } from \"../interfaces/i-size\";\r\n\r\ntype LineWalker = (point: IPoint, normal: IPoint) => unknown;\r\n\r\nabstract class PatternBase {\r\n    /** Returns the suggested image size for optimum quality */\r\n    public abstract get suggestedImageSize(): ISize;\r\n    public abstract get nbLines(): number;\r\n\r\n    /**\r\n     * @param lineId integer\r\n     * @param step in canvas pixels\r\n     */\r\n    public abstract walkOnLine(lineId: number, step: number, callback: LineWalker): void;\r\n}\r\n\r\nexport { LineWalker, PatternBase }\r\n","import { distance, IPoint } from \"../interfaces/i-point\";\r\nimport { ISize } from \"../interfaces/i-size\";\r\nimport { Parameters } from \"../parameters\";\r\nimport { LineWalker, PatternBase } from \"./pattern-base\";\r\n\r\nclass PatternPolygon extends PatternBase {\r\n    private readonly _center: IPoint;\r\n    private readonly _suggestedImageSize: ISize;\r\n    private readonly _linesSpacing: number;\r\n    private readonly _maxSegments: number;\r\n    private readonly _nbSides: number;\r\n\r\n    public constructor(imageSize: ISize, linesSpacing: number) {\r\n        super();\r\n\r\n        this._center = {\r\n            x: 0.5 * imageSize.width,\r\n            y: 0.5 * imageSize.height,\r\n        };\r\n\r\n        this._suggestedImageSize = {\r\n            width: imageSize.width,\r\n            height: imageSize.height,\r\n        };\r\n\r\n        this._linesSpacing = linesSpacing;\r\n        this._nbSides = Parameters.linesSides;\r\n\r\n        const diagonal = Math.sqrt(imageSize.width * imageSize.width + imageSize.height * imageSize.height);\r\n        this._maxSegments = Math.ceil(this._nbSides * diagonal / linesSpacing);\r\n    }\r\n\r\n    public get suggestedImageSize(): ISize {\r\n        return this._suggestedImageSize;\r\n    }\r\n\r\n    public get nbLines(): number {\r\n        return 1;\r\n    }\r\n\r\n    public walkOnLine(_lineId: number, step: number, callback: LineWalker): void {\r\n        const insideAngle = Math.PI * (this._nbSides - 2) / this._nbSides; // inside angle of a regular polygon\r\n        const dSideLength = 2 * this._linesSpacing / Math.tan(insideAngle / 2) / this._nbSides;\r\n        const startSideLength = 0.5 * dSideLength;\r\n\r\n        let startPoint: IPoint = {\r\n            x: this._center.x,\r\n            y: this._center.y,\r\n        };\r\n        for (let iSide = 0; iSide < this._maxSegments; iSide++) {\r\n            const sideLength = startSideLength + iSide * dSideLength;\r\n            const tangentAngle = Math.PI + (iSide % this._nbSides) * 2 * Math.PI / this._nbSides;\r\n\r\n            const endPoint: IPoint = {\r\n                x: startPoint.x + sideLength * Math.cos(tangentAngle),\r\n                y: startPoint.y + sideLength * Math.sin(tangentAngle),\r\n            };\r\n\r\n            const normal: IPoint = {\r\n                x: Math.cos(tangentAngle + Math.PI / 2),\r\n                y: Math.sin(tangentAngle + Math.PI / 2),\r\n            };\r\n\r\n            const segmentLength = distance(startPoint, endPoint);\r\n            for (let iSubstep = 0; iSubstep * step < segmentLength; iSubstep++) {\r\n                const currentLength = iSubstep * step;\r\n                const progression = currentLength / segmentLength;\r\n                const point: IPoint = {\r\n                    x: startPoint.x * (1 - progression) + endPoint.x * progression,\r\n                    y: startPoint.y * (1 - progression) + endPoint.y * progression,\r\n                };\r\n                callback(point, normal);\r\n            }\r\n\r\n            startPoint = endPoint;\r\n        }\r\n    }\r\n}\r\n\r\nexport { PatternPolygon };\r\n","import { IPoint } from \"../interfaces/i-point\";\r\nimport { ISize } from \"../interfaces/i-size\";\r\nimport { Parameters } from \"../parameters\";\r\nimport { LineWalker, PatternBase } from \"./pattern-base\";\r\n\r\nclass PatternSpiral extends PatternBase {\r\n    private readonly _center: IPoint;\r\n    private readonly _suggestedImageSize: ISize;\r\n    private readonly _radiusGap: number;\r\n    private readonly _maxAngle: number;\r\n\r\n    public constructor(imageSize: ISize, linesSpacing: number) {\r\n        super();\r\n\r\n        this._center = {\r\n            x: 0.5 * imageSize.width,\r\n            y: 0.5 * imageSize.height,\r\n        };\r\n\r\n        this._suggestedImageSize = {\r\n            width: imageSize.width,\r\n            height: imageSize.height,\r\n        };\r\n\r\n        this._radiusGap = 0.5 * linesSpacing;\r\n\r\n        const diagonal = Math.sqrt(imageSize.width * imageSize.width + imageSize.height * imageSize.height);\r\n        const nbSemiCircles = Math.ceil(diagonal / linesSpacing);\r\n        this._maxAngle = nbSemiCircles * Math.PI;\r\n    }\r\n\r\n    public get suggestedImageSize(): ISize {\r\n        return this._suggestedImageSize;\r\n    }\r\n\r\n    public get nbLines(): number {\r\n        return 1;\r\n    }\r\n\r\n    public walkOnLine(_lineId: number, step: number, callback: LineWalker): void {\r\n        const orientation = Parameters.orientationInRadians;\r\n        const cosOrientation = Math.cos(orientation);\r\n        const sinOrientation = Math.sin(orientation);\r\n\r\n        let angle = 0;\r\n        while (angle < this._maxAngle) {\r\n            const cosAngle = Math.cos(angle);\r\n            const sinAngle = Math.sin(angle);\r\n\r\n            const semiCircleId = Math.ceil((angle - orientation) / Math.PI);\r\n            const radius = (semiCircleId + 0.125) * this._radiusGap;\r\n            const centerOffset = this._radiusGap * (0.5 - (semiCircleId % 2));\r\n\r\n            const point: IPoint = {\r\n                x: this._center.x + centerOffset * cosOrientation + radius * cosAngle,\r\n                y: this._center.y + centerOffset * sinOrientation + radius * sinAngle,\r\n            };\r\n            const normal: IPoint = {\r\n                x: -cosAngle,\r\n                y: -sinAngle,\r\n            };\r\n\r\n            callback(point, normal);\r\n\r\n            angle += step / radius;\r\n        }\r\n    }\r\n}\r\n\r\nexport { PatternSpiral }\r\n","import { ISize } from \"../interfaces/i-size\";\r\nimport { IPoint, distance } from \"../interfaces/i-point\";\r\nimport { LineWalker, PatternBase } from \"./pattern-base\";\r\n\r\nimport { Parameters } from \"../parameters\";\r\n\r\ninterface ILine {\r\n    start: IPoint;\r\n    end: IPoint;\r\n    length: number;\r\n}\r\n\r\nenum ELinesOrientation {\r\n    HORIZONTAL,\r\n    VERTICAL,\r\n    DIAGONAL,\r\n}\r\n\r\nclass PatternStraightLines extends PatternBase {\r\n    private readonly _suggestedImageSize: ISize;\r\n\r\n    private readonly _normal: IPoint;\r\n    private readonly _lines: ILine[];\r\n\r\n    public constructor(imageSize: ISize, linesSpacing: number) {\r\n        super();\r\n\r\n        this._normal = {\r\n            x: -Math.sin(Parameters.orientationInRadians),\r\n            y: Math.cos(Parameters.orientationInRadians),\r\n        };\r\n\r\n        let linesOrientation = ELinesOrientation.DIAGONAL;\r\n        if (Parameters.orientationInDegrees % 180 === 90) {\r\n            linesOrientation = ELinesOrientation.VERTICAL;\r\n        } else if (Parameters.orientationInDegrees % 180 === 0) {\r\n            linesOrientation = ELinesOrientation.HORIZONTAL;\r\n        }\r\n\r\n        this._lines = [];\r\n        this._lines.push(PatternStraightLines.computeLine(0, linesSpacing, linesOrientation, this._normal, imageSize));\r\n\r\n        const maximumLinesNeeded = PatternStraightLines.computeMaximumLinesNeeded(imageSize, linesSpacing);\r\n        const maxAbsLine = maximumLinesNeeded / 2 + 1;\r\n        for (let iAbsLine = 1; iAbsLine < maxAbsLine; iAbsLine++) {\r\n            for (let iSide = -1; iSide <= 2; iSide += 2) {\r\n                const iLine = iAbsLine * iSide;\r\n                const line = PatternStraightLines.computeLine(iLine, linesSpacing, linesOrientation, this._normal, imageSize);\r\n\r\n                const ROUNDING_ERROR = 0.1;\r\n\r\n                const xOutOfBounds = line.start.x < -ROUNDING_ERROR || line.start.x > imageSize.width - 1 + ROUNDING_ERROR;\r\n                const yOutOfBounds = line.start.y < -ROUNDING_ERROR || line.start.y > imageSize.height - 1 + ROUNDING_ERROR;\r\n\r\n                if (xOutOfBounds || yOutOfBounds) {\r\n                    break;\r\n                }\r\n\r\n                this._lines.push(line);\r\n            }\r\n        }\r\n        this._suggestedImageSize = PatternStraightLines.computeBestImageSize(imageSize, this._lines.length, linesOrientation);\r\n    }\r\n\r\n    public get suggestedImageSize(): ISize {\r\n        return this._suggestedImageSize;\r\n    }\r\n\r\n    public get nbLines(): number {\r\n        return this._lines.length;\r\n    }\r\n\r\n    public walkOnLine(lineId: number, step: number, callback: LineWalker): void {\r\n        const line = this._lines[lineId];\r\n\r\n        function computePoint(completion: number): IPoint {\r\n            return {\r\n                x: line.start.x * (1 - completion) + line.end.x * completion,\r\n                y: line.start.y * (1 - completion) + line.end.y * completion,\r\n            };\r\n        }\r\n\r\n        const maxNbSteps = line.length / step;\r\n        for (let iStep = 0; iStep < maxNbSteps; iStep++) {\r\n            const completion = (iStep * step) / line.length;\r\n\r\n            const point = computePoint(completion);\r\n            callback(point, this._normal);\r\n        }\r\n\r\n        const lastPoint = computePoint(1);\r\n        callback(lastPoint, this._normal);\r\n    }\r\n\r\n    private static computeLine(iLine: number, linesSpacing: number, linesOrientation: ELinesOrientation, normal: IPoint, imageSize: ISize): ILine {\r\n        const tangent: IPoint = {\r\n            x: normal.y,\r\n            y: -normal.x,\r\n        };\r\n\r\n        const start: IPoint = {\r\n            x: 0.5 * imageSize.width + iLine * linesSpacing * normal.x,\r\n            y: 0.5 * imageSize.height + iLine * linesSpacing * normal.y,\r\n        };\r\n        const end: IPoint = { x: start.x, y: start.y };\r\n\r\n        const maxX = imageSize.width - 1;\r\n        const maxY = imageSize.height - 1;\r\n\r\n        if (linesOrientation === ELinesOrientation.HORIZONTAL) {\r\n            start.x = 0;\r\n            end.x = maxX;\r\n        } else if (linesOrientation === ELinesOrientation.VERTICAL) {\r\n            start.y = 0;\r\n            end.y = maxY;\r\n        } else {\r\n            const startAdjustment = Math.min(start.x / tangent.x, start.y / tangent.y);\r\n            start.x -= startAdjustment * tangent.x;\r\n            start.y -= startAdjustment * tangent.y;\r\n\r\n            const endAdjustment = Math.min((maxX - end.x) / tangent.x, (maxY - end.y) / tangent.y);\r\n            end.x += endAdjustment * tangent.x;\r\n            end.y += endAdjustment * tangent.y;\r\n        }\r\n\r\n        return {\r\n            start,\r\n            end,\r\n            length: distance(start, end),\r\n        };\r\n    }\r\n\r\n    private static computeBestImageSize(imageSize: ISize, nbLines: number, orientation: ELinesOrientation): ISize {\r\n        if (orientation === ELinesOrientation.HORIZONTAL) {\r\n            return {\r\n                width: imageSize.width,\r\n                height: nbLines,\r\n            };\r\n        } else if (orientation === ELinesOrientation.VERTICAL) {\r\n            return {\r\n                width: nbLines,\r\n                height: imageSize.height,\r\n            };\r\n        }\r\n\r\n        return {\r\n            width: imageSize.width,\r\n            height: imageSize.height,\r\n        };\r\n    }\r\n\r\n    private static computeMaximumLinesNeeded(imageSize: ISize, linesSpacing: number): number {\r\n        const diagonal = Math.sqrt(imageSize.width * imageSize.width + imageSize.height * imageSize.height)\r\n        return Math.ceil(diagonal / linesSpacing);\r\n    }\r\n}\r\n\r\nexport { PatternStraightLines }\r\n","import { IPoint } from \"../interfaces/i-point\";\r\nimport { ISize } from \"../interfaces/i-size\";\r\n\r\ninterface IPlotterInfo {\r\n    backgroundColor: string;\r\n    lineColor: string;\r\n    lineThickness: number;\r\n    blur: number;\r\n}\r\n\r\nconst ANGLE_THRESHOLD = Math.PI * 0.01;\r\n\r\nabstract class PlotterBase {\r\n    public abstract get size(): ISize;\r\n\r\n    public abstract initialize(infos: IPlotterInfo): void;\r\n    public abstract finalize(): void;\r\n\r\n    public get hasStartedALine(): boolean {\r\n        return this._hasStartedALine;\r\n    }\r\n\r\n    public startLine(): void {\r\n        this._hasStartedALine = true;\r\n        this.startLineInternal();\r\n\r\n        this.lastDrawnPoint = null;\r\n        this.potentialNextPoint = null;\r\n    }\r\n\r\n    public addPointToLine(x: number, y: number): void {\r\n        const newPoint: IPoint = { x, y };\r\n\r\n        if (this.lastDrawnPoint === null) {\r\n            this.lastDrawnPoint = newPoint;\r\n            this.addFirstPointToLineInternal(this.lastDrawnPoint.x, this.lastDrawnPoint.y);\r\n        } else if (this.potentialNextPoint === null) {\r\n            this.potentialNextPoint = newPoint;\r\n        } else {\r\n            const angle = PlotterBase.computeAngle(this.lastDrawnPoint, this.potentialNextPoint, newPoint);\r\n\r\n            if (angle > ANGLE_THRESHOLD) {\r\n                this.addPointToLineInternal(this.potentialNextPoint.x, this.potentialNextPoint.y); // this point cannot be skipped because it defines a significant angle\r\n                this.lastDrawnPoint = this.potentialNextPoint;\r\n            }\r\n            this.potentialNextPoint = newPoint;\r\n        }\r\n    }\r\n\r\n    public endLine(): void {\r\n        if (this.potentialNextPoint !== null) {\r\n            this.addPointToLineInternal(this.potentialNextPoint.x, this.potentialNextPoint.y);\r\n        }\r\n        this.lastDrawnPoint = null;\r\n        this.potentialNextPoint = null;\r\n\r\n        this.endLineInternal();\r\n        this._hasStartedALine = false;\r\n    }\r\n\r\n    protected abstract startLineInternal(): void;\r\n    protected abstract addFirstPointToLineInternal(x: number, y: number): void;\r\n    protected abstract addPointToLineInternal(x: number, y: number): void;\r\n    protected abstract endLineInternal(): void;\r\n\r\n    /** Smallest absolute angle difference between vectors p2-p1 and p3-p2 */\r\n    private static computeAngle(p1: IPoint, p2: IPoint, p3: IPoint): number {\r\n        const angle1 = Math.atan2(p2.y - p1.y, p2.x - p1.x); // in [-PI,PI] (warped)\r\n        const angle2 = Math.atan2(p3.y - p2.y, p3.x - p2.x); // in [-PI,PI] (warped)\r\n\r\n        const diffAngle = Math.abs(angle1 - angle2); // in [0, 2 * PI] (warped)\r\n        return Math.min(diffAngle, 2 * Math.PI - diffAngle);\r\n    }\r\n\r\n    private lastDrawnPoint: IPoint;\r\n    private potentialNextPoint: IPoint;\r\n    private _hasStartedALine: boolean = false;\r\n}\r\n\r\nexport { PlotterBase, IPlotterInfo, ISize }\r\n","import { PlotterBase, IPlotterInfo, ISize } from \"./plotter-base\";\r\n\r\nimport \"../page-interface-generated\";\r\n\r\nclass PlotterCanvas2D extends PlotterBase {\r\n    private readonly canvas: HTMLCanvasElement;\r\n    private readonly context: CanvasRenderingContext2D;\r\n    private readonly cssPixel: number;\r\n\r\n    public constructor() {\r\n        super();\r\n\r\n        this.canvas = Page.Canvas.getCanvas();\r\n        this.context = this.canvas.getContext(\"2d\", { alpha: false });\r\n        this.cssPixel = window.devicePixelRatio ?? 1;\r\n    }\r\n\r\n    public get size(): ISize {\r\n        return {\r\n            width: Math.floor(this.canvas.width / this.cssPixel),\r\n            height: Math.floor(this.canvas.height / this.cssPixel),\r\n        };\r\n    }\r\n\r\n    public initialize(infos: IPlotterInfo): void {\r\n        this.resizeCanvas();\r\n\r\n        this.context.fillStyle = infos.backgroundColor;\r\n        this.context.strokeStyle = infos.lineColor;\r\n        this.context.lineWidth = infos.lineThickness * this.cssPixel;\r\n        this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);\r\n    }\r\n\r\n    // tslint:disable-next-line:no-empty\r\n    public finalize(): void { }\r\n\r\n    public set blur(value: number) {\r\n        if (value === 0) {\r\n            this.canvas.style.filter = \"\";\r\n        } else {\r\n            this.canvas.style.filter = `blur(${value}px)`;\r\n        }\r\n    }\r\n\r\n    protected startLineInternal(): void {\r\n        this.context.beginPath();\r\n    }\r\n\r\n    protected addFirstPointToLineInternal(rawX: number, rawY: number): void {\r\n        const x = rawX * this.cssPixel;\r\n        const y = rawY * this.cssPixel;\r\n        this.context.moveTo(x, y);\r\n    }\r\n\r\n    protected addPointToLineInternal(rawX: number, rawY: number): void {\r\n        const x = rawX * this.cssPixel;\r\n        const y = rawY * this.cssPixel;\r\n        this.context.lineTo(x, y);\r\n    }\r\n\r\n    protected endLineInternal(): void {\r\n        this.context.stroke();\r\n        this.context.closePath();\r\n    }\r\n\r\n    private resizeCanvas(): void {\r\n        const actualWidth = Math.floor(this.cssPixel * this.canvas.clientWidth);\r\n        const actualHeight = Math.floor(this.cssPixel * this.canvas.clientHeight);\r\n\r\n        if (this.canvas.width !== actualWidth || this.canvas.height !== actualHeight) {\r\n            this.canvas.width = actualWidth;\r\n            this.canvas.height = actualHeight;\r\n        }\r\n    }\r\n}\r\n\r\nexport { PlotterCanvas2D }\r\n","import { PlotterBase, IPlotterInfo, ISize } from \"./plotter-base\";\r\n\r\nconst WIDTH = 1000;\r\nconst HEIGHT = 1000;\r\n\r\nclass PlotterSVG extends PlotterBase {\r\n    private stringParts: string[];\r\n    private hasBlur: boolean;\r\n\r\n    public constructor() {\r\n        super();\r\n    }\r\n\r\n    public get size(): ISize {\r\n        return {\r\n            width: WIDTH,\r\n            height: HEIGHT,\r\n        };\r\n    }\r\n\r\n    public initialize(infos: IPlotterInfo): void {\r\n        this.hasBlur = infos.blur > 0;\r\n\r\n        this.stringParts = [];\r\n\r\n        this.stringParts.push(`<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\\n`);\r\n        this.stringParts.push(`<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" viewBox=\"0 0 ${WIDTH} ${HEIGHT}\">\\n`);\r\n\r\n        if (this.hasBlur) {\r\n            const blurEffectId = \"gaussianBlur\";\r\n\r\n            this.stringParts.push(`\\t<defs>\\n`);\r\n            this.stringParts.push(`\\t\\t<filter id=\"${blurEffectId}\" x=\"0\" y=\"0\">\\n`);\r\n            this.stringParts.push(`\\t\\t\\t<feGaussianBlur in=\"SourceGraphic\" stdDeviation=\"${infos.blur}\"/>\\n`);\r\n            this.stringParts.push(`\\t\\t</filter>\\n`);\r\n            this.stringParts.push(`\\t</defs>\\n`);\r\n            this.stringParts.push(`\\t<g filter=\"url(#${blurEffectId})\">\\n`);\r\n        }\r\n\r\n        this.stringParts.push(`\\t<rect fill=\"${infos.backgroundColor}\" stroke=\"none\" x=\"0\" y=\"0\" width=\"${WIDTH}\" height=\"${HEIGHT}\"/>\\n`);\r\n        this.stringParts.push(`\\t<g fill=\"none\" stroke=\"${infos.lineColor}\" stroke-width=\"${infos.lineThickness}\" stroke-linejoin=\"round\">\\n`);\r\n    }\r\n\r\n    // tslint:disable-next-line:no-empty\r\n    public finalize(): void {\r\n        if (this.hasBlur) {\r\n            this.stringParts.push(`\\t\\t</g>\\n`);\r\n        }\r\n\r\n        this.stringParts.push(`\\t</g>\\n`);\r\n        this.stringParts.push(`</svg>\\n`);\r\n    }\r\n\r\n    public endLineInternal(): void {\r\n        this.stringParts.push(`\"/>\\n`);\r\n    }\r\n\r\n    public export(): string {\r\n        const start = Date.now();\r\n        const result = this.stringParts.join(\"\");\r\n        console.log(`Concatenation took ${Date.now() - start} ms.`);\r\n        return result;\r\n    }\r\n\r\n    protected startLineInternal(): void {\r\n        this.stringParts.push(`\\t\\t<path d=\"`);\r\n    }\r\n\r\n    protected addFirstPointToLineInternal(rawX: number, rawY: number): void {\r\n        const x = rawX.toFixed(1);\r\n        const y = rawY.toFixed(1);\r\n        this.stringParts.push(`M${x},${y}L`);\r\n    }\r\n\r\n    protected addPointToLineInternal(rawX: number, rawY: number): void {\r\n        const x = rawX.toFixed(1);\r\n        const y = rawY.toFixed(1);\r\n        this.stringParts.push(`${x},${y} `);\r\n    }\r\n}\r\n\r\nexport { PlotterSVG }\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module\n// This entry module is referenced by other modules so it can't be inlined\n__webpack_require__(633);\n"],"sourceRoot":""}