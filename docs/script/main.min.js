/******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/ts/helpers.ts":
/*!***************************!*\
  !*** ./src/ts/helpers.ts ***!
  \***************************/
/*! flagged exports */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export chooseLines [provided] [no usage info] [missing usage info prevents renaming] */
/*! export choosePattern [provided] [no usage info] [missing usage info prevents renaming] */
/*! export downloadTextFile [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.downloadTextFile = exports.choosePattern = exports.chooseLines = void 0;
var parameters_1 = __webpack_require__(/*! ./parameters */ "./src/ts/parameters.ts");
var lines_straight_lines_1 = __webpack_require__(/*! ./lines/lines-straight-lines */ "./src/ts/lines/lines-straight-lines.ts");
var lines_sines_1 = __webpack_require__(/*! ./lines/lines-sines */ "./src/ts/lines/lines-sines.ts");
var lines_spiral_1 = __webpack_require__(/*! ./lines/lines-spiral */ "./src/ts/lines/lines-spiral.ts");
var lines_polygon_1 = __webpack_require__(/*! ./lines/lines-polygon */ "./src/ts/lines/lines-polygon.ts");
var pattern_wave_1 = __webpack_require__(/*! ./pattern/pattern-wave */ "./src/ts/pattern/pattern-wave.ts");
var pattern_dithering_1 = __webpack_require__(/*! ./pattern/pattern-dithering */ "./src/ts/pattern/pattern-dithering.ts");
function chooseLines(imageSizeInPlotter, linesSpacing) {
    var chosenType = parameters_1.Parameters.linesType;
    if (chosenType === parameters_1.ELinesType.STRAIGHT) {
        return new lines_straight_lines_1.LinesStraightLines(imageSizeInPlotter, linesSpacing);
    }
    else if (chosenType === parameters_1.ELinesType.SPIRAL) {
        return new lines_spiral_1.LinesSpiral(imageSizeInPlotter, linesSpacing);
    }
    else if (chosenType === parameters_1.ELinesType.POLYGON) {
        return new lines_polygon_1.LinesPolygon(imageSizeInPlotter, linesSpacing);
    }
    else {
        return new lines_sines_1.LinesSines(imageSizeInPlotter, linesSpacing);
    }
}
exports.chooseLines = chooseLines;
function choosePattern(imageFitting, linesSpacing) {
    var pattern = parameters_1.Parameters.pattern;
    if (pattern === parameters_1.EPattern.WAVES) {
        return new pattern_wave_1.PatternWave(imageFitting, linesSpacing);
    }
    else {
        return new pattern_dithering_1.PatternDithering(imageFitting, linesSpacing);
    }
}
exports.choosePattern = choosePattern;
function downloadTextFile(content, filename) {
    var fileType = "text/plain";
    var blob = new Blob([content], { type: fileType });
    if (typeof window.navigator !== "undefined" && typeof window.navigator.msSaveBlob !== "undefined") {
        window.navigator.msSaveBlob(blob, filename);
    }
    else {
        var objectUrl_1 = URL.createObjectURL(blob);
        var linkElement = document.createElement('a');
        linkElement.download = filename;
        linkElement.href = objectUrl_1;
        linkElement.dataset.downloadurl = fileType + ":" + linkElement.download + ":" + linkElement.href;
        linkElement.style.display = "none";
        document.body.appendChild(linkElement);
        linkElement.click();
        document.body.removeChild(linkElement);
        setTimeout(function () {
            URL.revokeObjectURL(objectUrl_1);
        }, 5000);
    }
}
exports.downloadTextFile = downloadTextFile;


/***/ }),

/***/ "./src/ts/input-image.ts":
/*!*******************************!*\
  !*** ./src/ts/input-image.ts ***!
  \*******************************/
/*! flagged exports */
/*! export InputImage [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__ */
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InputImage = void 0;
var InputImage = (function () {
    function InputImage(image) {
        this.hiddenCanvas = document.createElement("canvas");
        this.hiddenContext = this.hiddenCanvas.getContext("2d");
        this.sourceImage = image;
        this._size = {
            width: 0,
            height: 0,
        };
        this.resize({ width: image.width, height: image.height });
    }
    Object.defineProperty(InputImage.prototype, "size", {
        get: function () {
            return this._size;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(InputImage.prototype, "width", {
        get: function () {
            return this._size.width;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(InputImage.prototype, "height", {
        get: function () {
            return this._size.height;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(InputImage.prototype, "sourceImageAspectRatio", {
        get: function () {
            return this.sourceImage.width / this.sourceImage.height;
        },
        enumerable: false,
        configurable: true
    });
    InputImage.prototype.resize = function (wantedSize) {
        var wantedWidth = Math.min(this.sourceImage.width, wantedSize.width);
        var wantedHeight = Math.min(this.sourceImage.height, wantedSize.height);
        if (this.width !== wantedWidth || this.height !== wantedHeight) {
            console.log("Resize image from " + this.width + "x" + this.height + " to " + wantedWidth + "x" + wantedHeight + ".");
            this._size.width = wantedWidth;
            this._size.height = wantedHeight;
            this.hiddenCanvas.width = this.width;
            this.hiddenCanvas.height = this.height;
            this.hiddenContext.drawImage(this.sourceImage, 0, 0, this.width, this.height);
            var fullPixelsArray = this.hiddenContext.getImageData(0, 0, this.width, this.height).data;
            this.valueArray = new Uint8ClampedArray(this.width * this.height);
            for (var i = 0; i < this.valueArray.length; i++) {
                var r = fullPixelsArray[4 * i];
                var g = fullPixelsArray[4 * i + 1];
                var b = fullPixelsArray[4 * i + 2];
                this.valueArray[i] = (r + g + b) / 3;
            }
        }
    };
    InputImage.prototype.sample = function (normalizedCoords) {
        var pixelCoords = {
            x: normalizedCoords.x * (this._size.width - 1),
            y: normalizedCoords.y * (this._size.height - 1),
        };
        var floorPixelCoords = {
            x: Math.floor(pixelCoords.x),
            y: Math.floor(pixelCoords.y),
        };
        var fractPixelCoords = {
            x: pixelCoords.x - floorPixelCoords.x,
            y: pixelCoords.y - floorPixelCoords.y,
        };
        var topLeft = this.getPixel(floorPixelCoords.x, floorPixelCoords.y);
        var topRight = this.getPixel(floorPixelCoords.x + 1, floorPixelCoords.y);
        var bottomLeft = this.getPixel(floorPixelCoords.x, floorPixelCoords.y + 1);
        var bottomRight = this.getPixel(floorPixelCoords.x + 1, floorPixelCoords.y + 1);
        var top = this.interpolate(topLeft, topRight, fractPixelCoords.x);
        var bottom = this.interpolate(bottomLeft, bottomRight, fractPixelCoords.x);
        var interpolated = this.interpolate(top, bottom, fractPixelCoords.y);
        return interpolated / 255;
    };
    InputImage.prototype.interpolate = function (a, b, x) {
        return a * (1 - x) + b * x;
    };
    InputImage.prototype.getPixel = function (x, y) {
        if (x < 0 || y < 0 || x >= this.width || y >= this.height) {
            return 0;
        }
        return this.valueArray[y * this.width + x];
    };
    return InputImage;
}());
exports.InputImage = InputImage;


/***/ }),

/***/ "./src/ts/interfaces/i-point.ts":
/*!**************************************!*\
  !*** ./src/ts/interfaces/i-point.ts ***!
  \**************************************/
/*! flagged exports */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export distance [provided] [no usage info] [missing usage info prevents renaming] */
/*! export rotate [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__ */
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.rotate = exports.distance = void 0;
function distance(a, b) {
    var dX = a.x - b.x;
    var dY = a.y - b.y;
    return Math.sqrt(dX * dX + dY * dY);
}
exports.distance = distance;
function rotate(p, angle) {
    var cosAngle = Math.cos(angle);
    var sinAngle = Math.sin(angle);
    return {
        x: p.x * cosAngle - p.y * sinAngle,
        y: p.x * sinAngle + p.y * cosAngle,
    };
}
exports.rotate = rotate;


/***/ }),

/***/ "./src/ts/lines/lines-base.ts":
/*!************************************!*\
  !*** ./src/ts/lines/lines-base.ts ***!
  \************************************/
/*! flagged exports */
/*! export LinesBase [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__ */
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LinesBase = void 0;
var LinesBase = (function () {
    function LinesBase() {
    }
    return LinesBase;
}());
exports.LinesBase = LinesBase;


/***/ }),

/***/ "./src/ts/lines/lines-polygon.ts":
/*!***************************************!*\
  !*** ./src/ts/lines/lines-polygon.ts ***!
  \***************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: top-level-this-exports, __webpack_exports__, __webpack_require__ */
/*! CommonJS bailout: this is used directly at 2:17-21 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LinesPolygon = void 0;
var i_point_1 = __webpack_require__(/*! ../interfaces/i-point */ "./src/ts/interfaces/i-point.ts");
var parameters_1 = __webpack_require__(/*! ../parameters */ "./src/ts/parameters.ts");
var lines_base_1 = __webpack_require__(/*! ./lines-base */ "./src/ts/lines/lines-base.ts");
var LinesPolygon = (function (_super) {
    __extends(LinesPolygon, _super);
    function LinesPolygon(imageSize, linesSpacing) {
        var _this = _super.call(this) || this;
        _this._center = {
            x: 0.5 * imageSize.width,
            y: 0.5 * imageSize.height,
        };
        _this._suggestedImageSize = {
            width: imageSize.width,
            height: imageSize.height,
        };
        _this._linesSpacing = linesSpacing;
        _this._nbSides = parameters_1.Parameters.linesSides;
        var diagonal = Math.sqrt(imageSize.width * imageSize.width + imageSize.height * imageSize.height);
        _this._maxSegments = Math.ceil(_this._nbSides * diagonal / linesSpacing);
        return _this;
    }
    Object.defineProperty(LinesPolygon.prototype, "suggestedImageSize", {
        get: function () {
            return this._suggestedImageSize;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LinesPolygon.prototype, "nbLines", {
        get: function () {
            return 1;
        },
        enumerable: false,
        configurable: true
    });
    LinesPolygon.prototype.walkOnLine = function (_lineId, step, callback) {
        var insideAngle = Math.PI * (this._nbSides - 2) / this._nbSides;
        var dSideLength = 2 * this._linesSpacing / Math.tan(insideAngle / 2) / this._nbSides;
        var startSideLength = 0.5 * dSideLength;
        var orientationAngle = parameters_1.Parameters.orientationInRadians;
        var cosOrientation = Math.cos(orientationAngle);
        var sinOrientation = Math.sin(orientationAngle);
        var startPoint = {
            x: this._center.x,
            y: this._center.y,
        };
        for (var iSide = 0; iSide < this._maxSegments; iSide++) {
            var sideLength = startSideLength + iSide * dSideLength;
            var tangentAngle = Math.PI + (iSide % this._nbSides) * 2 * Math.PI / this._nbSides;
            var endPoint = {
                x: startPoint.x + sideLength * Math.cos(tangentAngle),
                y: startPoint.y + sideLength * Math.sin(tangentAngle),
            };
            var normalAngle = tangentAngle + orientationAngle + Math.PI / 2;
            var normal = { x: Math.cos(normalAngle), y: Math.sin(normalAngle) };
            var segmentLength = i_point_1.distance(startPoint, endPoint);
            for (var iSubstep = 0; iSubstep * step < segmentLength; iSubstep++) {
                var currentLength = iSubstep * step;
                var progression = currentLength / segmentLength;
                var rawPointX = startPoint.x * (1 - progression) + endPoint.x * progression - this._center.x;
                var rawPointY = startPoint.y * (1 - progression) + endPoint.y * progression - this._center.y;
                var point = {
                    x: cosOrientation * rawPointX - sinOrientation * rawPointY + this._center.x,
                    y: sinOrientation * rawPointX + cosOrientation * rawPointY + this._center.y,
                };
                callback(point, normal);
            }
            startPoint = endPoint;
        }
    };
    return LinesPolygon;
}(lines_base_1.LinesBase));
exports.LinesPolygon = LinesPolygon;


/***/ }),

/***/ "./src/ts/lines/lines-sines.ts":
/*!*************************************!*\
  !*** ./src/ts/lines/lines-sines.ts ***!
  \*************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: top-level-this-exports, __webpack_exports__, __webpack_require__ */
/*! CommonJS bailout: this is used directly at 2:17-21 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LinesSines = void 0;
var lines_base_1 = __webpack_require__(/*! ./lines-base */ "./src/ts/lines/lines-base.ts");
var parameters_1 = __webpack_require__(/*! ../parameters */ "./src/ts/parameters.ts");
var LinesSines = (function (_super) {
    __extends(LinesSines, _super);
    function LinesSines(imageSize, linesSpacing) {
        var _this = _super.call(this) || this;
        _this._frequency = parameters_1.Parameters.linesFrequency;
        _this._amplitude = parameters_1.Parameters.linesAmplitude * 0.2 * Math.max(imageSize.width, imageSize.height);
        _this._normal = {
            x: -Math.sin(parameters_1.Parameters.orientationInRadians),
            y: Math.cos(parameters_1.Parameters.orientationInRadians),
        };
        _this._lines = [];
        _this._lines.push(LinesSines.computeLine(0, linesSpacing, _this._normal, imageSize));
        var maximumLinesNeeded = _this.computeMaximumLinesNeeded(imageSize, linesSpacing);
        var maxAbsLine = maximumLinesNeeded / 2 + 1;
        for (var iAbsLine = 1; iAbsLine < maxAbsLine; iAbsLine++) {
            for (var iSide = -1; iSide <= 2; iSide += 2) {
                var iLine = iAbsLine * iSide;
                var line = LinesSines.computeLine(iLine, linesSpacing, _this._normal, imageSize);
                _this._lines.push(line);
            }
        }
        _this._suggestedImageSize = { width: imageSize.width, height: imageSize.height };
        return _this;
    }
    Object.defineProperty(LinesSines.prototype, "suggestedImageSize", {
        get: function () {
            return this._suggestedImageSize;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LinesSines.prototype, "nbLines", {
        get: function () {
            return this._lines.length;
        },
        enumerable: false,
        configurable: true
    });
    LinesSines.prototype.walkOnLine = function (lineId, step, callback) {
        var _this = this;
        var line = this._lines[lineId];
        var computePoint = function (completion) {
            var wave = _this._amplitude * Math.sin(2 * Math.PI * completion * _this._frequency);
            return {
                x: line.start.x * (1 - completion) + line.end.x * completion + wave * _this._normal.x,
                y: line.start.y * (1 - completion) + line.end.y * completion + wave * _this._normal.y,
            };
        };
        var maxNbSteps = line.length / step;
        for (var iStep = 0; iStep < maxNbSteps; iStep++) {
            var completion = (iStep * step) / line.length;
            var point = computePoint(completion);
            callback(point, this._normal);
        }
        var lastPoint = computePoint(1);
        callback(lastPoint, this._normal);
    };
    LinesSines.computeLine = function (iLine, linesSpacing, normal, imageSize) {
        var lineLength = Math.sqrt(imageSize.width * imageSize.width + imageSize.height * imageSize.height);
        var tangent = {
            x: normal.y,
            y: -normal.x,
        };
        var center = {
            x: 0.5 * imageSize.width + iLine * linesSpacing * normal.x,
            y: 0.5 * imageSize.height + iLine * linesSpacing * normal.y,
        };
        var start = {
            x: center.x - 0.5 * lineLength * tangent.x,
            y: center.y - 0.5 * lineLength * tangent.y,
        };
        var end = {
            x: center.x + 0.5 * lineLength * tangent.x,
            y: center.y + 0.5 * lineLength * tangent.y,
        };
        return {
            start: start,
            end: end,
            length: lineLength,
        };
    };
    LinesSines.prototype.computeMaximumLinesNeeded = function (imageSize, linesSpacing) {
        var width = imageSize.width + 2 * this._amplitude;
        var height = imageSize.height + 2 * this._amplitude;
        var diagonal = Math.sqrt(width * width + height * height);
        return Math.ceil(diagonal / linesSpacing);
    };
    return LinesSines;
}(lines_base_1.LinesBase));
exports.LinesSines = LinesSines;


/***/ }),

/***/ "./src/ts/lines/lines-spiral.ts":
/*!**************************************!*\
  !*** ./src/ts/lines/lines-spiral.ts ***!
  \**************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: top-level-this-exports, __webpack_exports__, __webpack_require__ */
/*! CommonJS bailout: this is used directly at 2:17-21 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LinesSpiral = void 0;
var parameters_1 = __webpack_require__(/*! ../parameters */ "./src/ts/parameters.ts");
var lines_base_1 = __webpack_require__(/*! ./lines-base */ "./src/ts/lines/lines-base.ts");
var LinesSpiral = (function (_super) {
    __extends(LinesSpiral, _super);
    function LinesSpiral(imageSize, linesSpacing) {
        var _this = _super.call(this) || this;
        _this._center = {
            x: 0.5 * imageSize.width,
            y: 0.5 * imageSize.height,
        };
        _this._suggestedImageSize = {
            width: imageSize.width,
            height: imageSize.height,
        };
        _this._radiusGap = 0.5 * linesSpacing;
        var diagonal = Math.sqrt(imageSize.width * imageSize.width + imageSize.height * imageSize.height);
        var nbSemiCircles = Math.ceil(diagonal / linesSpacing);
        _this._maxAngle = nbSemiCircles * Math.PI;
        return _this;
    }
    Object.defineProperty(LinesSpiral.prototype, "suggestedImageSize", {
        get: function () {
            return this._suggestedImageSize;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LinesSpiral.prototype, "nbLines", {
        get: function () {
            return 1;
        },
        enumerable: false,
        configurable: true
    });
    LinesSpiral.prototype.walkOnLine = function (_lineId, step, callback) {
        var orientation = parameters_1.Parameters.orientationInRadians;
        var cosOrientation = Math.cos(orientation);
        var sinOrientation = Math.sin(orientation);
        var angle = 0;
        while (angle < this._maxAngle) {
            var cosAngle = Math.cos(angle);
            var sinAngle = Math.sin(angle);
            var semiCircleId = Math.ceil((angle - orientation) / Math.PI);
            var radius = (semiCircleId + 0.125) * this._radiusGap;
            var centerOffset = this._radiusGap * (0.5 - (semiCircleId % 2));
            var point = {
                x: this._center.x + centerOffset * cosOrientation + radius * cosAngle,
                y: this._center.y + centerOffset * sinOrientation + radius * sinAngle,
            };
            var normal = {
                x: -cosAngle,
                y: -sinAngle,
            };
            callback(point, normal);
            angle += step / radius;
        }
    };
    return LinesSpiral;
}(lines_base_1.LinesBase));
exports.LinesSpiral = LinesSpiral;


/***/ }),

/***/ "./src/ts/lines/lines-straight-lines.ts":
/*!**********************************************!*\
  !*** ./src/ts/lines/lines-straight-lines.ts ***!
  \**********************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: top-level-this-exports, __webpack_exports__, __webpack_require__ */
/*! CommonJS bailout: this is used directly at 2:17-21 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LinesStraightLines = void 0;
var i_point_1 = __webpack_require__(/*! ../interfaces/i-point */ "./src/ts/interfaces/i-point.ts");
var lines_base_1 = __webpack_require__(/*! ./lines-base */ "./src/ts/lines/lines-base.ts");
var parameters_1 = __webpack_require__(/*! ../parameters */ "./src/ts/parameters.ts");
var ELinesOrientation;
(function (ELinesOrientation) {
    ELinesOrientation[ELinesOrientation["HORIZONTAL"] = 0] = "HORIZONTAL";
    ELinesOrientation[ELinesOrientation["VERTICAL"] = 1] = "VERTICAL";
    ELinesOrientation[ELinesOrientation["DIAGONAL"] = 2] = "DIAGONAL";
})(ELinesOrientation || (ELinesOrientation = {}));
var LinesStraightLines = (function (_super) {
    __extends(LinesStraightLines, _super);
    function LinesStraightLines(imageSize, linesSpacing) {
        var _this = _super.call(this) || this;
        _this._normal = {
            x: -Math.sin(parameters_1.Parameters.orientationInRadians),
            y: Math.cos(parameters_1.Parameters.orientationInRadians),
        };
        var linesOrientation = ELinesOrientation.DIAGONAL;
        if (parameters_1.Parameters.orientationInDegrees % 180 === 90) {
            linesOrientation = ELinesOrientation.VERTICAL;
        }
        else if (parameters_1.Parameters.orientationInDegrees % 180 === 0) {
            linesOrientation = ELinesOrientation.HORIZONTAL;
        }
        _this._lines = [];
        _this._lines.push(LinesStraightLines.computeLine(0, linesSpacing, linesOrientation, _this._normal, imageSize));
        var maximumLinesNeeded = LinesStraightLines.computeMaximumLinesNeeded(imageSize, linesSpacing);
        var maxAbsLine = maximumLinesNeeded / 2 + 1;
        for (var iAbsLine = 1; iAbsLine < maxAbsLine; iAbsLine++) {
            for (var iSide = -1; iSide <= 2; iSide += 2) {
                var iLine = iAbsLine * iSide;
                var line = LinesStraightLines.computeLine(iLine, linesSpacing, linesOrientation, _this._normal, imageSize);
                var ROUNDING_ERROR = 0.1;
                var xOutOfBounds = line.start.x < -ROUNDING_ERROR || line.start.x > imageSize.width - 1 + ROUNDING_ERROR;
                var yOutOfBounds = line.start.y < -ROUNDING_ERROR || line.start.y > imageSize.height - 1 + ROUNDING_ERROR;
                if (xOutOfBounds || yOutOfBounds) {
                    break;
                }
                _this._lines.push(line);
            }
        }
        _this._suggestedImageSize = LinesStraightLines.computeBestImageSize(imageSize, _this._lines.length, linesOrientation);
        return _this;
    }
    Object.defineProperty(LinesStraightLines.prototype, "suggestedImageSize", {
        get: function () {
            return this._suggestedImageSize;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LinesStraightLines.prototype, "nbLines", {
        get: function () {
            return this._lines.length;
        },
        enumerable: false,
        configurable: true
    });
    LinesStraightLines.prototype.walkOnLine = function (lineId, step, callback) {
        var line = this._lines[lineId];
        function computePoint(completion) {
            return {
                x: line.start.x * (1 - completion) + line.end.x * completion,
                y: line.start.y * (1 - completion) + line.end.y * completion,
            };
        }
        var maxNbSteps = line.length / step;
        for (var iStep = 0; iStep < maxNbSteps; iStep++) {
            var completion = (iStep * step) / line.length;
            var point = computePoint(completion);
            callback(point, this._normal);
        }
        var lastPoint = computePoint(1);
        callback(lastPoint, this._normal);
    };
    LinesStraightLines.computeLine = function (iLine, linesSpacing, linesOrientation, normal, imageSize) {
        var tangent = {
            x: normal.y,
            y: -normal.x,
        };
        var start = {
            x: 0.5 * imageSize.width + iLine * linesSpacing * normal.x,
            y: 0.5 * imageSize.height + iLine * linesSpacing * normal.y,
        };
        var end = { x: start.x, y: start.y };
        var maxX = imageSize.width - 1;
        var maxY = imageSize.height - 1;
        if (linesOrientation === ELinesOrientation.HORIZONTAL) {
            start.x = 0;
            end.x = maxX;
        }
        else if (linesOrientation === ELinesOrientation.VERTICAL) {
            start.y = 0;
            end.y = maxY;
        }
        else {
            var startAdjustment = Math.min(start.x / tangent.x, start.y / tangent.y);
            start.x -= startAdjustment * tangent.x;
            start.y -= startAdjustment * tangent.y;
            var endAdjustment = Math.min((maxX - end.x) / tangent.x, (maxY - end.y) / tangent.y);
            end.x += endAdjustment * tangent.x;
            end.y += endAdjustment * tangent.y;
        }
        return {
            start: start,
            end: end,
            length: i_point_1.distance(start, end),
        };
    };
    LinesStraightLines.computeBestImageSize = function (imageSize, nbLines, orientation) {
        if (orientation === ELinesOrientation.HORIZONTAL) {
            return {
                width: imageSize.width,
                height: nbLines,
            };
        }
        else if (orientation === ELinesOrientation.VERTICAL) {
            return {
                width: nbLines,
                height: imageSize.height,
            };
        }
        return {
            width: imageSize.width,
            height: imageSize.height,
        };
    };
    LinesStraightLines.computeMaximumLinesNeeded = function (imageSize, linesSpacing) {
        var diagonal = Math.sqrt(imageSize.width * imageSize.width + imageSize.height * imageSize.height);
        return Math.ceil(diagonal / linesSpacing);
    };
    return LinesStraightLines;
}(lines_base_1.LinesBase));
exports.LinesStraightLines = LinesStraightLines;


/***/ }),

/***/ "./src/ts/main.ts":
/*!************************!*\
  !*** ./src/ts/main.ts ***!
  \************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: top-level-this-exports, __webpack_exports__, __webpack_require__ */
/*! CommonJS bailout: this is used directly at 2:23-27 */
/*! CommonJS bailout: this is used directly at 9:26-30 */
/*! CommonJS bailout: this is used directly at 14:20-24 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var parameters_1 = __webpack_require__(/*! ./parameters */ "./src/ts/parameters.ts");
var input_image_1 = __webpack_require__(/*! ./input-image */ "./src/ts/input-image.ts");
var plotter_canvas_2d_1 = __webpack_require__(/*! ./plotter/plotter-canvas-2d */ "./src/ts/plotter/plotter-canvas-2d.ts");
var plotter_svg_1 = __webpack_require__(/*! ./plotter/plotter-svg */ "./src/ts/plotter/plotter-svg.ts");
var Helpers = __importStar(__webpack_require__(/*! ./helpers */ "./src/ts/helpers.ts"));
__webpack_require__(/*! ./page-interface-generated */ "./src/ts/page-interface-generated.ts");
function plot(image, plotter) {
    var start = performance.now();
    if (image == null) {
        console.log("Image not loaded!");
        return;
    }
    plotter.resize();
    var imageFitting = plotter.fitImage(image.sourceImageAspectRatio);
    var baseLineSpacing = 1 / parameters_1.Parameters.linesCount;
    var linesSpacing = baseLineSpacing * imageFitting.zoomFactor;
    var lines = Helpers.chooseLines(imageFitting.sizeInPlotter, linesSpacing);
    var pattern = Helpers.choosePattern(imageFitting, linesSpacing);
    image.resize(lines.suggestedImageSize);
    var displayInfos = pattern.buildPlotterInfos();
    plotter.initialize(displayInfos);
    for (var iLine = 0; iLine < lines.nbLines; iLine++) {
        pattern.drawLine(lines, iLine, image, plotter);
    }
    plotter.finalize();
    console.log("Plotting took " + (performance.now() - start) + " ms.");
}
var inputImage = null;
var canvasPlotter = new plotter_canvas_2d_1.PlotterCanvas2D();
function plotOnCanvas() {
    plot(inputImage, canvasPlotter);
}
parameters_1.Parameters.addRedrawObserver(plotOnCanvas);
function updateBlur(blur) {
    canvasPlotter.blur = blur;
}
parameters_1.Parameters.addBlurChangeObserver(updateBlur);
updateBlur(parameters_1.Parameters.blur);
parameters_1.Parameters.addDownloadObserver(function () {
    var svgPlotter = new plotter_svg_1.PlotterSVG();
    plot(inputImage, svgPlotter);
    var svgString = svgPlotter.export();
    var filename = "image-as-sines.svg";
    Helpers.downloadTextFile(svgString, filename);
});
function onImageLoad(image) {
    inputImage = new input_image_1.InputImage(image);
    Page.Canvas.showLoader(false);
    plotOnCanvas();
}
parameters_1.Parameters.addFileUploadObserver(onImageLoad);
Page.Canvas.showLoader(true);
var defaultImage = new Image();
defaultImage.addEventListener("load", function () {
    onImageLoad(defaultImage);
});
defaultImage.src = "./resources/cat.jpg";


/***/ }),

/***/ "./src/ts/page-interface-generated.ts":
/*!********************************************!*\
  !*** ./src/ts/page-interface-generated.ts ***!
  \********************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements:  */
/***/ (function() {




/***/ }),

/***/ "./src/ts/parameters.ts":
/*!******************************!*\
  !*** ./src/ts/parameters.ts ***!
  \******************************/
/*! flagged exports */
/*! export ELinesType [provided] [no usage info] [missing usage info prevents renaming] */
/*! export EPattern [provided] [no usage info] [missing usage info prevents renaming] */
/*! export Parameters [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EPattern = exports.ELinesType = exports.Parameters = void 0;
__webpack_require__(/*! ./page-interface-generated */ "./src/ts/page-interface-generated.ts");
var controlId = {
    UPLOAD_INPUT_IMAGE: "input-image-upload-button",
    LINES_TYPE: "lines-type-tabs-id",
    LINES_COUNT: "lines-count-range-id",
    ORIENTATION: "orientation-range-id",
    LINES_SIDES: "lines-sides-range-id",
    LINES_AMPLITUDE: "lines-amplitude-range-id",
    LINES_FREQUENCY: "lines-frequency-range-id",
    PATTERN: "pattern-tabs-id",
    AMPLITUDE: "max-amplitude-range-id",
    FREQUENCY: "max-frequency-range-id",
    ANGLE: "angle-range-id",
    WAVE_SQUARENESS: "wave-squareness-range-id",
    LINE_THICKNESS: "line-thickness-range-id",
    INVERT_COLORS: "invert-colors-checkbox-id",
    BLUR: "blur-range-id",
    DOWNLOAD: "result-download-id",
};
var ELinesType;
(function (ELinesType) {
    ELinesType["STRAIGHT"] = "0";
    ELinesType["SPIRAL"] = "1";
    ELinesType["POLYGON"] = "2";
    ELinesType["SINES"] = "3";
})(ELinesType || (ELinesType = {}));
exports.ELinesType = ELinesType;
var EPattern;
(function (EPattern) {
    EPattern["WAVES"] = "0";
    EPattern["DITHERING"] = "1";
})(EPattern || (EPattern = {}));
exports.EPattern = EPattern;
var redrawObservers = [];
function triggerRedraw() {
    for (var _i = 0, redrawObservers_1 = redrawObservers; _i < redrawObservers_1.length; _i++) {
        var observer = redrawObservers_1[_i];
        observer();
    }
}
Page.Tabs.addObserver(controlId.LINES_TYPE, triggerRedraw);
Page.Range.addLazyObserver(controlId.LINES_COUNT, triggerRedraw);
Page.Range.addLazyObserver(controlId.ORIENTATION, triggerRedraw);
Page.Range.addLazyObserver(controlId.LINES_SIDES, triggerRedraw);
Page.Range.addLazyObserver(controlId.LINES_AMPLITUDE, triggerRedraw);
Page.Range.addLazyObserver(controlId.LINES_FREQUENCY, triggerRedraw);
Page.Tabs.addObserver(controlId.PATTERN, triggerRedraw);
Page.Range.addLazyObserver(controlId.AMPLITUDE, triggerRedraw);
Page.Range.addLazyObserver(controlId.FREQUENCY, triggerRedraw);
Page.Range.addLazyObserver(controlId.ANGLE, triggerRedraw);
Page.Range.addLazyObserver(controlId.WAVE_SQUARENESS, triggerRedraw);
Page.Range.addLazyObserver(controlId.LINE_THICKNESS, triggerRedraw);
Page.Checkbox.addObserver(controlId.INVERT_COLORS, triggerRedraw);
Page.Canvas.Observers.canvasResize.push(triggerRedraw);
var Parameters = (function () {
    function Parameters() {
    }
    Parameters.addFileUploadObserver = function (callback) {
        Page.FileControl.addUploadObserver(controlId.UPLOAD_INPUT_IMAGE, function (filesList) {
            if (filesList.length === 1) {
                Page.Canvas.showLoader(true);
                var reader_1 = new FileReader();
                reader_1.onload = function () {
                    var image = new Image();
                    image.addEventListener("load", function () {
                        callback(image);
                    });
                    image.src = reader_1.result;
                };
                reader_1.readAsDataURL(filesList[0]);
            }
        });
    };
    Object.defineProperty(Parameters, "linesType", {
        get: function () {
            return Page.Tabs.getValues(controlId.LINES_TYPE)[0];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parameters, "linesCount", {
        get: function () {
            return Page.Range.getValue(controlId.LINES_COUNT);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parameters, "orientationInDegrees", {
        get: function () {
            return Page.Range.getValue(controlId.ORIENTATION);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parameters, "orientationInRadians", {
        get: function () {
            return this.orientationInDegrees / 180 * Math.PI;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parameters, "linesSides", {
        get: function () {
            return Page.Range.getValue(controlId.LINES_SIDES);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parameters, "linesAmplitude", {
        get: function () {
            return Page.Range.getValue(controlId.LINES_AMPLITUDE);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parameters, "linesFrequency", {
        get: function () {
            return Page.Range.getValue(controlId.LINES_FREQUENCY);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parameters, "pattern", {
        get: function () {
            return Page.Tabs.getValues(controlId.PATTERN)[0];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parameters, "maxAmplitude", {
        get: function () {
            return Page.Range.getValue(controlId.AMPLITUDE);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parameters, "maxFrequency", {
        get: function () {
            return Page.Range.getValue(controlId.FREQUENCY);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parameters, "angle", {
        get: function () {
            return Page.Range.getValue(controlId.ANGLE);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parameters, "waveSquareness", {
        get: function () {
            return Page.Range.getValue(controlId.WAVE_SQUARENESS);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parameters, "lineThickness", {
        get: function () {
            return Page.Range.getValue(controlId.LINE_THICKNESS);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parameters, "invertColors", {
        get: function () {
            return Page.Checkbox.isChecked(controlId.INVERT_COLORS);
        },
        enumerable: false,
        configurable: true
    });
    Parameters.addRedrawObserver = function (callback) {
        redrawObservers.push(callback);
    };
    Object.defineProperty(Parameters, "blur", {
        get: function () {
            return Page.Range.getValue(controlId.BLUR);
        },
        enumerable: false,
        configurable: true
    });
    Parameters.addBlurChangeObserver = function (callback) {
        Page.Range.addObserver(controlId.BLUR, callback);
    };
    Parameters.addDownloadObserver = function (callback) {
        Page.FileControl.addDownloadObserver(controlId.DOWNLOAD, callback);
    };
    return Parameters;
}());
exports.Parameters = Parameters;
function udpateControlsVisibility() {
    var type = Parameters.linesType;
    Page.Controls.setVisibility(controlId.LINES_SIDES, type === ELinesType.POLYGON);
    Page.Controls.setVisibility(controlId.LINES_AMPLITUDE, type === ELinesType.SINES);
    Page.Controls.setVisibility(controlId.LINES_FREQUENCY, type === ELinesType.SINES);
    var pattern = Parameters.pattern;
    Page.Controls.setVisibility(controlId.ANGLE, pattern === EPattern.WAVES);
    Page.Controls.setVisibility(controlId.WAVE_SQUARENESS, pattern === EPattern.WAVES);
    Page.Controls.setVisibility(controlId.LINE_THICKNESS, pattern === EPattern.WAVES);
}
Page.Tabs.addObserver(controlId.LINES_TYPE, udpateControlsVisibility);
Page.Tabs.addObserver(controlId.PATTERN, udpateControlsVisibility);
udpateControlsVisibility();


/***/ }),

/***/ "./src/ts/pattern/pattern-base.ts":
/*!****************************************!*\
  !*** ./src/ts/pattern/pattern-base.ts ***!
  \****************************************/
/*! flagged exports */
/*! export PatternBase [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__ */
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PatternBase = void 0;
var PatternBase = (function () {
    function PatternBase() {
    }
    return PatternBase;
}());
exports.PatternBase = PatternBase;


/***/ }),

/***/ "./src/ts/pattern/pattern-dithering.ts":
/*!*********************************************!*\
  !*** ./src/ts/pattern/pattern-dithering.ts ***!
  \*********************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: top-level-this-exports, __webpack_exports__, __webpack_require__ */
/*! CommonJS bailout: this is used directly at 2:17-21 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PatternDithering = void 0;
var parameters_1 = __webpack_require__(/*! ../parameters */ "./src/ts/parameters.ts");
var pattern_base_1 = __webpack_require__(/*! ./pattern-base */ "./src/ts/pattern/pattern-base.ts");
function clamp(min, max, x) {
    if (x < min) {
        return min;
    }
    else if (x > max) {
        return max;
    }
    return x;
}
var PatternDithering = (function (_super) {
    __extends(PatternDithering, _super);
    function PatternDithering(imageFitting, linesSpacing) {
        var _this = _super.call(this) || this;
        _this.samplingFunction = PatternDithering.chooseBestSamplingFunction();
        _this.imageFitting = imageFitting;
        _this.linesThickness = Math.max(1, parameters_1.Parameters.maxAmplitude * linesSpacing);
        var MIN_FREQUENCY = 10;
        var MAX_FREQUENCY = 500;
        var xFrequency = parameters_1.Parameters.maxFrequency;
        var baseMaxFrequency = MIN_FREQUENCY * (1 - xFrequency) + MAX_FREQUENCY * xFrequency;
        var frequency = baseMaxFrequency / imageFitting.zoomFactor;
        _this.step = 1 / frequency;
        return _this;
    }
    PatternDithering.prototype.buildPlotterInfos = function () {
        return {
            backgroundColor: parameters_1.Parameters.invertColors ? "black" : "white",
            lineColor: parameters_1.Parameters.invertColors ? "white" : "black",
            lineThickness: this.linesThickness,
            roundLinecap: false,
            blur: parameters_1.Parameters.blur,
        };
    };
    PatternDithering.prototype.drawLine = function (lines, lineId, image, plotter) {
        var _this = this;
        var iPortion = Math.round(1000 * Math.random());
        lines.walkOnLine(lineId, this.step, function (point) {
            var normalizedCoords = _this.imageFitting.pixelToRelative(point);
            var outOfImage = normalizedCoords.x < 0 || normalizedCoords.x > 1 || normalizedCoords.y < 0 || normalizedCoords.y > 1;
            if (outOfImage) {
                if (plotter.hasStartedALine) {
                    plotter.endLine();
                }
            }
            else {
                var localDarkness = clamp(0, 1, _this.samplingFunction(image, normalizedCoords));
                var iQuantifiedColor = Math.floor(localDarkness * 0.99 * PatternDithering.ditheringPatterns.length);
                var ditheringPattern = PatternDithering.ditheringPatterns[iQuantifiedColor];
                var isDarkPortion = ditheringPattern[Math.floor(iPortion % ditheringPattern.length)] > 0.5;
                if (isDarkPortion) {
                    if (!plotter.hasStartedALine) {
                        plotter.startLine();
                    }
                    var absolutePoint = _this.imageFitting.relativeToAbsolute(point);
                    plotter.addPointToLine(absolutePoint.x, absolutePoint.y);
                }
                else if (plotter.hasStartedALine) {
                    var absolutePoint = _this.imageFitting.relativeToAbsolute(point);
                    plotter.addPointToLine(absolutePoint.x, absolutePoint.y);
                    plotter.endLine();
                }
                iPortion++;
            }
        });
        if (plotter.hasStartedALine) {
            plotter.endLine();
        }
    };
    PatternDithering.chooseBestSamplingFunction = function () {
        if (parameters_1.Parameters.invertColors) {
            return function (inputImage, coords) { return inputImage.sample(coords); };
        }
        else {
            return function (inputImage, coords) { return 1 - inputImage.sample(coords); };
        }
    };
    PatternDithering.ditheringPatterns = [
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
        [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0],
        [0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0],
        [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0],
        [1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0],
        [1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0],
        [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0],
        [1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0],
        [1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0],
        [1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1],
        [1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1],
        [1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1],
        [1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    ];
    return PatternDithering;
}(pattern_base_1.PatternBase));
exports.PatternDithering = PatternDithering;


/***/ }),

/***/ "./src/ts/pattern/pattern-wave.ts":
/*!****************************************!*\
  !*** ./src/ts/pattern/pattern-wave.ts ***!
  \****************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: top-level-this-exports, __webpack_exports__, __webpack_require__ */
/*! CommonJS bailout: this is used directly at 2:17-21 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PatternWave = void 0;
var parameters_1 = __webpack_require__(/*! ../parameters */ "./src/ts/parameters.ts");
var pattern_base_1 = __webpack_require__(/*! ./pattern-base */ "./src/ts/pattern/pattern-base.ts");
var PatternWave = (function (_super) {
    __extends(PatternWave, _super);
    function PatternWave(imageFitting, linesSpacing) {
        var _this = _super.call(this) || this;
        _this.waveFunction = PatternWave.computeWaveFunction();
        _this.normalRotationFunction = PatternWave.computeNormalRotationFunction();
        _this.samplingFunction = PatternWave.chooseBestSamplingFunction();
        _this.imageFitting = imageFitting;
        var baseMaxFrequency = 2500 * parameters_1.Parameters.maxFrequency;
        _this.maxFrequency = baseMaxFrequency / imageFitting.zoomFactor;
        _this.maxAmplitude = 0.5 * (linesSpacing - parameters_1.Parameters.lineThickness) * parameters_1.Parameters.maxAmplitude;
        var samplesPerPixel = Math.max(1, 2 * _this.maxFrequency);
        _this.step = 1 / samplesPerPixel;
        return _this;
    }
    PatternWave.prototype.buildPlotterInfos = function () {
        return {
            backgroundColor: parameters_1.Parameters.invertColors ? "black" : "white",
            lineColor: parameters_1.Parameters.invertColors ? "white" : "black",
            lineThickness: parameters_1.Parameters.lineThickness,
            roundLinecap: true,
            blur: parameters_1.Parameters.blur,
        };
    };
    PatternWave.prototype.drawLine = function (lines, lineId, image, plotter) {
        var _this = this;
        var phase = 0;
        lines.walkOnLine(lineId, this.step, function (point, normal) {
            var normalizedCoords = _this.imageFitting.pixelToRelative(point);
            var outOfImage = normalizedCoords.x < 0 || normalizedCoords.x > 1 || normalizedCoords.y < 0 || normalizedCoords.y > 1;
            if (outOfImage) {
                if (plotter.hasStartedALine) {
                    plotter.endLine();
                }
            }
            else {
                var localDarkness = _this.samplingFunction(image, normalizedCoords);
                var localAmplitude = localDarkness * _this.maxAmplitude;
                var localHeight = _this.waveFunction(phase, localAmplitude);
                var rotatedNormal = _this.normalRotationFunction(normal);
                var dX = localHeight * rotatedNormal.x;
                var dY = localHeight * rotatedNormal.y;
                var absolutePoint = _this.imageFitting.relativeToAbsolute(point);
                if (!plotter.hasStartedALine) {
                    plotter.startLine();
                }
                plotter.addPointToLine(absolutePoint.x + dX, absolutePoint.y + dY);
                var localFrequency = localDarkness * _this.maxFrequency;
                phase += localFrequency * _this.step;
            }
        });
        if (plotter.hasStartedALine) {
            plotter.endLine();
        }
    };
    PatternWave.computeNormalRotationFunction = function () {
        var angle = parameters_1.Parameters.angle * 2 * Math.PI;
        var cosAngle = Math.cos(angle);
        var sinAngle = Math.sin(angle);
        var lengthAdjustment = 1 / cosAngle;
        return function (normal) {
            return {
                x: (cosAngle * normal.x - sinAngle * normal.y) * lengthAdjustment,
                y: (sinAngle * normal.x + cosAngle * normal.y) * lengthAdjustment,
            };
        };
    };
    PatternWave.computeWaveFunction = function () {
        if (parameters_1.Parameters.waveSquareness < 0.005) {
            return function (phase, amplitude) { return amplitude * Math.sin(phase); };
        }
        var sharpness = 1 - 0.99 * parameters_1.Parameters.waveSquareness;
        return function (phase, amplitude) {
            var sinPhase = Math.sin(phase);
            return amplitude * Math.sign(sinPhase) * Math.pow(Math.abs(sinPhase), sharpness);
        };
    };
    PatternWave.chooseBestSamplingFunction = function () {
        if (parameters_1.Parameters.invertColors) {
            return function (inputImage, coords) { return Math.sqrt(inputImage.sample(coords)); };
        }
        else {
            return function (inputImage, coords) { return Math.sqrt(1.001 - inputImage.sample(coords)); };
        }
    };
    return PatternWave;
}(pattern_base_1.PatternBase));
exports.PatternWave = PatternWave;


/***/ }),

/***/ "./src/ts/plotter/plotter-base.ts":
/*!****************************************!*\
  !*** ./src/ts/plotter/plotter-base.ts ***!
  \****************************************/
/*! flagged exports */
/*! export PlotterBase [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__ */
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PlotterBase = void 0;
;
var ANGLE_THRESHOLD = Math.PI * 0.01;
var PlotterBase = (function () {
    function PlotterBase() {
        this._hasStartedALine = false;
    }
    Object.defineProperty(PlotterBase.prototype, "hasStartedALine", {
        get: function () {
            return this._hasStartedALine;
        },
        enumerable: false,
        configurable: true
    });
    PlotterBase.prototype.startLine = function () {
        this._hasStartedALine = true;
        this.startLineInternal();
        this.lastDrawnPoint = null;
        this.potentialNextPoint = null;
    };
    PlotterBase.prototype.addPointToLine = function (x, y) {
        var newPoint = { x: x, y: y };
        if (this.lastDrawnPoint === null) {
            this.lastDrawnPoint = newPoint;
            this.addFirstPointToLineInternal(this.lastDrawnPoint.x, this.lastDrawnPoint.y);
        }
        else if (this.potentialNextPoint === null) {
            this.potentialNextPoint = newPoint;
        }
        else {
            var angle = PlotterBase.computeAngle(this.lastDrawnPoint, this.potentialNextPoint, newPoint);
            if (angle > ANGLE_THRESHOLD) {
                this.addPointToLineInternal(this.potentialNextPoint.x, this.potentialNextPoint.y);
                this.lastDrawnPoint = this.potentialNextPoint;
            }
            this.potentialNextPoint = newPoint;
        }
    };
    PlotterBase.prototype.endLine = function () {
        if (this.potentialNextPoint !== null) {
            this.addPointToLineInternal(this.potentialNextPoint.x, this.potentialNextPoint.y);
        }
        this.lastDrawnPoint = null;
        this.potentialNextPoint = null;
        this.endLineInternal();
        this._hasStartedALine = false;
    };
    PlotterBase.prototype.fitImage = function (imageAspectRatio) {
        var plotterSize = this.size;
        var displayAspectRatio = plotterSize.width / plotterSize.height;
        var sizeInPlotter = {
            width: plotterSize.width,
            height: plotterSize.height,
        };
        if (imageAspectRatio > displayAspectRatio) {
            sizeInPlotter.height = Math.floor(sizeInPlotter.height * displayAspectRatio / imageAspectRatio);
        }
        else if (imageAspectRatio < displayAspectRatio) {
            sizeInPlotter.width = Math.floor(sizeInPlotter.width * imageAspectRatio / displayAspectRatio);
        }
        var offSetX = 0.5 * (plotterSize.width - sizeInPlotter.width);
        var offSetY = 0.5 * (plotterSize.height - sizeInPlotter.height);
        var relativeToAbsolute = function (relativeCoords) {
            return {
                x: relativeCoords.x + offSetX,
                y: relativeCoords.y + offSetY,
            };
        };
        var minSide = Math.min(sizeInPlotter.width, sizeInPlotter.height);
        var baseMinSide = Math.min(imageAspectRatio, 1 / imageAspectRatio);
        return {
            sizeInPlotter: sizeInPlotter,
            relativeToAbsolute: relativeToAbsolute,
            pixelToRelative: function (pixelCoordinates) {
                return {
                    x: pixelCoordinates.x / (sizeInPlotter.width - 1),
                    y: pixelCoordinates.y / (sizeInPlotter.height - 1),
                };
            },
            zoomFactor: minSide / baseMinSide,
        };
    };
    PlotterBase.computeAngle = function (p1, p2, p3) {
        var angle1 = Math.atan2(p2.y - p1.y, p2.x - p1.x);
        var angle2 = Math.atan2(p3.y - p2.y, p3.x - p2.x);
        var diffAngle = Math.abs(angle1 - angle2);
        return Math.min(diffAngle, 2 * Math.PI - diffAngle);
    };
    return PlotterBase;
}());
exports.PlotterBase = PlotterBase;


/***/ }),

/***/ "./src/ts/plotter/plotter-canvas-2d.ts":
/*!*********************************************!*\
  !*** ./src/ts/plotter/plotter-canvas-2d.ts ***!
  \*********************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: top-level-this-exports, __webpack_exports__, __webpack_require__ */
/*! CommonJS bailout: this is used directly at 2:17-21 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PlotterCanvas2D = void 0;
var plotter_base_1 = __webpack_require__(/*! ./plotter-base */ "./src/ts/plotter/plotter-base.ts");
__webpack_require__(/*! ../page-interface-generated */ "./src/ts/page-interface-generated.ts");
var PlotterCanvas2D = (function (_super) {
    __extends(PlotterCanvas2D, _super);
    function PlotterCanvas2D() {
        var _a;
        var _this = _super.call(this) || this;
        _this.canvas = Page.Canvas.getCanvas();
        _this.context = _this.canvas.getContext("2d", { alpha: false });
        _this.cssPixel = (_a = window.devicePixelRatio) !== null && _a !== void 0 ? _a : 1;
        return _this;
    }
    PlotterCanvas2D.prototype.resize = function () {
        var actualWidth = Math.floor(this.cssPixel * this.canvas.clientWidth);
        var actualHeight = Math.floor(this.cssPixel * this.canvas.clientHeight);
        if (this.canvas.width !== actualWidth || this.canvas.height !== actualHeight) {
            this.canvas.width = actualWidth;
            this.canvas.height = actualHeight;
        }
    };
    PlotterCanvas2D.prototype.initialize = function (infos) {
        this.context.fillStyle = infos.backgroundColor;
        this.context.strokeStyle = infos.lineColor;
        this.context.lineWidth = infos.lineThickness * this.cssPixel;
        this.context.lineJoin = "round";
        this.context.lineCap = infos.roundLinecap ? "round" : "butt";
        this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);
    };
    PlotterCanvas2D.prototype.finalize = function () { };
    Object.defineProperty(PlotterCanvas2D.prototype, "blur", {
        set: function (value) {
            if (value === 0) {
                this.canvas.style.filter = "";
            }
            else {
                this.canvas.style.filter = "blur(" + value + "px)";
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PlotterCanvas2D.prototype, "size", {
        get: function () {
            return {
                width: Math.floor(this.canvas.width / this.cssPixel),
                height: Math.floor(this.canvas.height / this.cssPixel),
            };
        },
        enumerable: false,
        configurable: true
    });
    PlotterCanvas2D.prototype.startLineInternal = function () {
        this.context.beginPath();
    };
    PlotterCanvas2D.prototype.addFirstPointToLineInternal = function (rawX, rawY) {
        var x = rawX * this.cssPixel;
        var y = rawY * this.cssPixel;
        this.context.moveTo(x, y);
    };
    PlotterCanvas2D.prototype.addPointToLineInternal = function (rawX, rawY) {
        var x = rawX * this.cssPixel;
        var y = rawY * this.cssPixel;
        this.context.lineTo(x, y);
    };
    PlotterCanvas2D.prototype.endLineInternal = function () {
        this.context.stroke();
        this.context.closePath();
    };
    return PlotterCanvas2D;
}(plotter_base_1.PlotterBase));
exports.PlotterCanvas2D = PlotterCanvas2D;


/***/ }),

/***/ "./src/ts/plotter/plotter-svg.ts":
/*!***************************************!*\
  !*** ./src/ts/plotter/plotter-svg.ts ***!
  \***************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: top-level-this-exports, __webpack_exports__, __webpack_require__ */
/*! CommonJS bailout: this is used directly at 2:17-21 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PlotterSVG = void 0;
var plotter_base_1 = __webpack_require__(/*! ./plotter-base */ "./src/ts/plotter/plotter-base.ts");
var WIDTH = 1000;
var HEIGHT = 1000;
var PlotterSVG = (function (_super) {
    __extends(PlotterSVG, _super);
    function PlotterSVG() {
        return _super.call(this) || this;
    }
    PlotterSVG.prototype.resize = function () {
    };
    PlotterSVG.prototype.initialize = function (infos) {
        this.hasBlur = infos.blur > 0;
        this.stringParts = [];
        this.stringParts.push("<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n");
        this.stringParts.push("<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" viewBox=\"0 0 " + WIDTH + " " + HEIGHT + "\">\n");
        if (this.hasBlur) {
            var blurEffectId = "gaussianBlur";
            this.stringParts.push("\t<defs>\n");
            this.stringParts.push("\t\t<filter id=\"" + blurEffectId + "\" x=\"0\" y=\"0\">\n");
            this.stringParts.push("\t\t\t<feGaussianBlur in=\"SourceGraphic\" stdDeviation=\"" + infos.blur + "\"/>\n");
            this.stringParts.push("\t\t</filter>\n");
            this.stringParts.push("\t</defs>\n");
            this.stringParts.push("\t<g filter=\"url(#" + blurEffectId + ")\">\n");
        }
        this.stringParts.push("\t<rect fill=\"" + infos.backgroundColor + "\" stroke=\"none\" x=\"0\" y=\"0\" width=\"" + WIDTH + "\" height=\"" + HEIGHT + "\"/>\n");
        var linecap = infos.roundLinecap ? " stroke-linecap=\"round\"" : "";
        this.stringParts.push("\t<g fill=\"none\" stroke=\"" + infos.lineColor + "\" stroke-width=\"" + infos.lineThickness + "\" stroke-linejoin=\"round\"" + linecap + ">\n");
    };
    PlotterSVG.prototype.finalize = function () {
        if (this.hasBlur) {
            this.stringParts.push("\t\t</g>\n");
        }
        this.stringParts.push("\t</g>\n");
        this.stringParts.push("</svg>\n");
    };
    PlotterSVG.prototype.endLineInternal = function () {
        this.stringParts.push("\"/>\n");
    };
    PlotterSVG.prototype.export = function () {
        var start = Date.now();
        var result = this.stringParts.join("");
        console.log("Concatenation took " + (Date.now() - start) + " ms.");
        return result;
    };
    Object.defineProperty(PlotterSVG.prototype, "size", {
        get: function () {
            return {
                width: WIDTH,
                height: HEIGHT,
            };
        },
        enumerable: false,
        configurable: true
    });
    PlotterSVG.prototype.startLineInternal = function () {
        this.stringParts.push("\t\t<path d=\"");
    };
    PlotterSVG.prototype.addFirstPointToLineInternal = function (rawX, rawY) {
        var x = rawX.toFixed(1);
        var y = rawY.toFixed(1);
        this.stringParts.push("M" + x + "," + y + "L");
    };
    PlotterSVG.prototype.addPointToLineInternal = function (rawX, rawY) {
        var x = rawX.toFixed(1);
        var y = rawY.toFixed(1);
        this.stringParts.push(x + "," + y + " ");
    };
    return PlotterSVG;
}(plotter_base_1.PlotterBase));
exports.PlotterSVG = PlotterSVG;


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	// startup
/******/ 	// Load entry module
/******/ 	__webpack_require__("./src/ts/main.ts");
/******/ 	// This entry module used 'exports' so it can't be inlined
/******/ })()
;
//# sourceMappingURL=main.min.js.map